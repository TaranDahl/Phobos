# 额外功能说明

> Merged by 緋紅熱茶

## 使用须知

- **请勿二次传播转发**，本平台用于EC整合包开发组合
- 存在开发中内容和待测试内容，但本平台完全公开
- 如只需在模组使用部分功能，请自行合并需要的内容
- 对于未发布pr的内容，请前往作者的github页面查找
- 对于需要反馈问题，请联系作者以寻求解决方案

## 温馨提醒

- 平台仍在持续更新中，新增内容较多，如果找不到更新改动说明中的内容，请善用查找搜索
- 当非大型功能被公版合并，此说明书将不再保留其功能介绍，而为方便使用，大型功能的说明仍会保留
- 如果在刚更换完dll时发生问题，请先尝试重启电脑，可能是dll未成功完全完成替换导致的，重启后若问题仍然存在，请反馈
- 使用某些功能出现小问题时，请不要觉得没什么关系或者问题不大就算了，只要是说明中没有明确提到的，都可以提出
- 提出建议、反馈问题时，请不要在群里直接说，善用@成员、私聊（或 `凛冬将至` 群在线文档），否则容易被遗忘或者根本没注意到

## 特别感谢

- 感谢 **`Phobos`** 的所有开发者和贡献者
- 感谢 **`Sidoupiar和水菌`** 给予的额外功能开发方面的帮助
- 感谢 **`钢铁之锤`** 制作了适配的EC开发组件
- 感谢 **`航味麻酱`** 制作了更多的拓展功能并帮助维护平台
- 感谢 **`凛冬将至`** 的**群友们**给予的思路并帮忙进行各种测试
- 感谢 **`pbs测试群`** 的**群友们**给予的思路并帮忙进行各种测试

## 0. Phobos-develop 基础功能

- 公版内容不做任何解释，请自行前往 **[Phobos文档](https://phobos.readthedocs.io/en/latest/)** 查阅公版最新的英文说明书
- 注意使用的是develop分支而不是build（名称中的build只是简单告诉你现在是在哪个build之后的版本），即公版部分内容也是随版本更新的，具体更新的内容可以根据《更新改动说明》中的commit编号进行搜索

## 1. Phobos-pulls 未合并功能

- 以下为其它 **Phobos Contributor** 制作的未合并功能，内容来自于 **[Phobos拉取](https://github.com/Phobos-developers/Phobos/pulls)**

  > 出现问题时不保修，出现严重问题时请联系我，我会将其剔除；当该部分的内容被公版合并时会从该说明书中移除

### 超武给予超武（ *SW tag that grants 1-time-use super weapons #1199 by FS-21* ）

在 `rulesmd.ini` 之中：

```ini
[SOMESW]                                     ; 任意超武
SW.GrantOneTime=                             ; SuperWeapon列表，同 `LimboDelivery`
SW.GrantOneTime.RollChances=                 ; 浮点型列表，百分比，同 `LimboDelivery`
SW.GrantOneTime.RandomWeightsN=              ; 整数型列表，同 `LimboDelivery`
SW.GrantOneTime.InitialReady=                ; 布尔值，是否所有新授予的超武都直接准备好发射，不填则默认对应超武的 `SW.InitialReady`
Message.GrantOneTimeLaunched=                ; CSF条目，主超武发射时，将为开火者显示的CSF文字
EVA.GrantOneTimeLaunched=                    ; EVA条目，主超武发射时，将为开火者播放的EVA语音
```

### 轰击抛射体增强（ *Trajectory projectiles enhancement #1246 by NaotoYuuki & Ollerus & CrimRecya* ）

在 `rulesmd.ini` 之中：

```ini
[SOMEPROJECTILE]                             ; 弹道抛体（不和原版四类抛体共存）
Trajectory=                                  ; Trajectory类型，以下为【Bombard】
Trajectory.Speed=100.0                       ; 弹道抛体的速度
Trajectory.Bombard.Height=0.0                ; 浮点型，抛体转向位置相对于目标的垂直高度
Trajectory.Bombard.FallPercent=1.0           ; 浮点型，抛体转向位置占发射位置与目标位置间水平距离的百分比，为0时转向位置是在发射位置上方，为1时转向位置是在目标位置上方
Trajectory.Bombard.FallPercentShift=0.0      ; 浮点型，抛体转向位置的最大随机距离间偏移量，随机值会与 `Trajectory.Bombard.FallPercent` 相加得到最终转向位置的水平距离百分比，为0时禁用功能
Trajectory.Bombard.FallScatter.Max=0.0       ; 浮点型，抛体转向位置将以 `Trajectory.Bombard.FallPercent` 和随机 `Trajectory.Bombard.FallPercentShift` 相加得到的位置为圆心，随机散布在以该值为半径的大圆内，为0时禁用功能
Trajectory.Bombard.FallScatter.Min=0.0       ; 浮点型，抛体转向位置将以 `Trajectory.Bombard.FallPercent` 和随机 `Trajectory.Bombard.FallPercentShift` 相加得到的位置为圆心，随机散布在以该值为半径的小圆外，不会大于 `Trajectory.Bombard.FallScatter.Max`
Trajectory.Bombard.FallScatter.Linear=no     ; 布尔值，抛体转向位置的随机范围是否仅限于垂直于发射位置与目标位置之间连线的直线上
Trajectory.Bombard.FreeFallOnTarget=yes      ; 布尔值，抛体是在转向位置重新发射并自由落体还是正常从转向位置行进到预定目标，为是即前者，为否则后者
Trajectory.Bombard.NoLaunch=no               ; 布尔值，抛体是否跳过前往转向位置的过程直接从转向位置落下
Trajectory.Bombard.FallSpeed=0.0             ; 浮点型，抛体在经过转向位置后的初始速度，如果为0会使用 `Trajectory.Speed` ，不能和 `Trajectory.Bombard.FreeFallOnTarget` 同时使用
Trajectory.Bombard.DetonationDistance=0.4    ; 浮点型，抛体在距离目标多远距离内就会引爆
Trajectory.Bombard.DetonationHeight=-1       ; 整数型，抛体位于什么高度时提前引爆，与 `Trajectory.Bombard.EarlyDetonation` 组合使用，为负数时不生效
Trajectory.Bombard.EarlyDetonation=no        ; 布尔值，抛体在 `Trajectory.Bombard.DetonationHeight` 启用时，是否在上升段高于该高度时引爆，否则在下降段低于该高度时引爆
Trajectory.Bombard.TargetSnapDistance=0.5    ; 浮点型，抛体引爆时，当前目标在多近的距离内弹头会吸附过去
Trajectory.Bombard.TurningPointAnims=        ; Anim列表，如果设置，将在抛体到达转向位置时播放随机动画，如果 `Trajectory.Bombard.FreeFallOnTarget` 为是，动画将与抛体一起在目标上方产生，如果 `Trajectory.Bombard.NoLaunch` 为是，动画将在炮弹落下的地方播放，无论它是否是自由落体
Trajectory.Bombard.LeadTimeCalculate=no      ; 布尔值，抛体在瞄准时是否计算目标的提前量
Trajectory.Bombard.OffsetCoord=0,0,0         ; FLH坐标，请写完整，抛体会瞄准目标的这个相对坐标进行攻击，支持在此基础上启用随机散布
Trajectory.Bombard.RotateCoord=0             ; 浮点型，是否按照武器的 `Burst` 在以 `Trajectory.Bombard.OffsetCoord` 为角平分线的角度内旋转抛体发射方向，为0代表不启用该逻辑（负值会反转旋转方向）
Trajectory.Bombard.MirrorCoord=yes           ; 布尔值，抛体在瞄准目标相对坐标进行攻击前，如果发射者开火时当前武器的 `Burst` 数为偶数，则 `Trajectory.Bombard.OffsetCoord` 中的L会镜像翻转，同时 `Trajectory.Bombard.RotateCoord` 计算的旋转方向也会反转，每一侧的每个相邻抛体之间的旋转角度不因此改变
Trajectory.Bombard.UseDisperseBurst=no       ; 布尔值，计算 `Trajectory.Bombard.RotateCoord` 时是否按照扩散它的上级扩散抛体的 `Trajectory.Disperse.WeaponBurst` 的值而非武器的 `Burst`
Trajectory.Bombard.AxisOfRotation=0,0,1      ; FLH坐标，请写完整，计算 `Trajectory.Bombard.RotateCoord` 时的旋转轴，旋转轴会随单位朝向或目标位置到发射位置的向量旋转，长度不重要，只看方向（相反的向量也会反转旋转方向）
Trajectory.Bombard.SubjectToGround=no        ; 布尔值，抛体低于地面高度时是否立刻引爆（抛体处于下降段时必定启用，此处定义的是上升段时是否立刻引爆）
Inaccurate=no                                ; 布尔值，（原有功能-引入）启用随机散布（在启用散布后，如果还想保证命中，最好搭配一个较大的爆炸范围或大一些的 `Trajectory.Bombard.TargetSnapDistance` ）
BallisticScatter.Min=0                       ; 浮点型，（原有功能-引入）最小散布距离，随距离增大而增大，代表每10格攻击距离最小散布偏移中心的单元格数
BallisticScatter.Max=                        ; 浮点型，（原有功能-引入）最大散布距离，随距离增大而增大，代表每10格攻击距离最大散布偏移中心的单元格数，默认值为 `CombatDamage` 中 `BallisticScatter` 的值
Gravity=6.0                                  ; 浮点型，（原有功能-引入）抛体所受重力大小
```

```{note}
- `Trajectory.Bombard.LeadTimeCalculate` 计算目标的提前量若 `Trajectory.Bombard.NoLaunch` 为是，则会在开火时延迟1帧发射且增加性能消耗，同时若抛体的速度过低，则会无法生效
```

### 超武左侧边栏（ *Exclusive SuperWeapon Sidebar #1384 by NetsuNegi & CrimRecya* ）

在 `uimd.ini` 之中：

```ini
[Sidebar]                                    ; 侧边栏设置
SuperWeaponSidebar=false                     ; 布尔值，是否开启侧边栏
SuperWeaponSidebar.Interval=0                ; 整数型，左右图标之间的距离（间隔）
SuperWeaponSidebar.LeftOffset=0              ; 整数型，图标最左侧和背景最左侧之间的距离，不会超过 `SuperWeaponSidebar.Interval`
SuperWeaponSidebar.CameoHeight=48            ; 整数型，上下图标的顶部之间的距离（间隔+高度），最低为48
SuperWeaponSidebar.Max=0                     ; 整数型，最左侧栏最多能显示几个超武（右边的每个栏递减一个最值），为0代表不做限制，自动判断
SuperWeaponSidebar.MaxColumns=               ; 整数型，最多显示几栏的超武
```

在 `rulesmd.ini` 之中：

```ini
[AudioVisual]                                ; 视听通用设置
SuperWeaponSidebar.AllowByDefault=no         ; 布尔值，所有超武是否优先在左侧边栏显示

[SOMESIDE]                                   ; 任意主阵营
SuperWeaponSidebar.OnPCX=                    ; PCX文件，需要后缀，玩家属于该阵营时，超武左侧边栏的开关处在未隐藏状态时的按钮素材，素材大小为固定 10×50
SuperWeaponSidebar.OffPCX=                   ; PCX文件，需要后缀，玩家属于该阵营时，超武左侧边栏的开关处在隐藏状态时的按钮素材，素材大小为固定 10×50
SuperWeaponSidebar.TopPCX=                   ; PCX文件，需要后缀，玩家属于该阵营时，超武左侧边栏的背景顶部素材，素材大小为 (`SuperWeaponSidebar.Interval` + 60) × 本素材高度（注意素材高度过高可能导致超出屏幕范围而弹窗，请合理搭配 `SuperWeaponSidebar.Max` 使用）
SuperWeaponSidebar.CenterPCX=                ; PCX文件，需要后缀，玩家属于该阵营时，超武左侧边栏的背景中部素材，每一个图标底部对应一个素材，素材大小为 (`SuperWeaponSidebar.Interval` + 60) × `SuperWeaponSidebar.CameoHeight`
SuperWeaponSidebar.BottomPCX=                ; PCX文件，需要后缀，玩家属于该阵营时，超武左侧边栏的背景底部素材，素材大小为 (`SuperWeaponSidebar.Interval` + 60) × 本素材高度（注意素材高度过高可能导致超出屏幕范围而弹窗，请合理搭配 `SuperWeaponSidebar.Max` 使用）

[SOMESW]                                     ; 任意超武
SuperWeaponSidebar.Allow=                    ; 布尔值，该超武是否优先在左侧边栏显示，默认值为 `AudioVisual` 中 `SuperWeaponSidebar.AllowByDefault` 的值
SuperWeaponSidebar.PriorityHouses=           ; 子阵营列表，若该超武优先在左侧边栏显示，则玩家属于这些子阵营时，会更优先将该超武排在左侧边栏上方（从上到下优先度从高到低）
SuperWeaponSidebar.RequiredHouses=           ; 子阵营列表，若该超武优先在左侧边栏显示，则玩家必须属于这些子阵营才能真正有机会在左侧边栏显示，默认为空，为空代表永远满足此条件
```

- 拥有快捷键功能，位于 [界面] 面板
- 默认开启状态，当存在可在左侧边栏显示的超武时才会显示出来

```{note}
- 关于10个按钮快捷键：
  - 按钮快捷键默认名为 `Fire Super Weapon XX` ，可以在csf中添加名为 `TXT_FIRE_TACTICAL_SW_XX` 和 `TXT_FIRE_TACTICAL_SW_XX_DESC` 的项目来分别重写其在快捷键页面中的选项名称和详细说明
  - 按钮设置快捷键键位后，当其位置超武在应该显示“就绪”文本时会改为显示其所在位置对应设置的快捷键键位
- 关于1个开关快捷键：
  - 开关快捷键默认名为 `Toggle Super Weapon Sidebar` ，可以在csf中添加名为 `TXT_TOGGLE_SW_SIDEBAR` 和 `TXT_TOGGLE_SW_SIDEBAR_DESC` 的项目来分别重写其在快捷键页面中的选项名称和详细说明（如 “发射超武 %02d” 在游戏中就会根据实际位置自动填写对应数字）
- 关于《超武侧栏背景》素材使用的推荐值：
```ini
SuperWeaponSidebar=yes
SuperWeaponSidebar.Interval=20
SuperWeaponSidebar.Max=14
SuperWeaponSidebar.MaxColumns=3
SuperWeaponSidebar.CameoHeight=50
SuperWeaponSidebar.LeftOffset=5
```

### 自定义坠落伤害（ *Customizing bridge fall damageFalling down damage #1421 by a851903106* ）

在 `rulesmd.ini` 之中：

```ini
[SOMETECHNO]                                 ; 任意步兵、车辆
FallingDownDamage=1.0                        ; 浮点型，单位从桥上坠落到地面上时受到的伤害，当值小于0时，其绝对值代表受到当前生命值多少比例的伤害；当值处于0和1之间时，该值代表受到生命值上限多少比例的伤害；当值大于1时，该值代表受到多少固定伤害
FallingDownDamage.Water=                     ; 浮点型，单位从桥上坠落到水面上时受到的伤害，当值小于0时，其绝对值代表受到当前生命值多少比例的伤害；当值处于0和1之间时，该值代表受到生命值上限多少比例的伤害；当值大于1时，该值代表受到多少固定伤害；默认值使用 `FallingDownDamage`
```

```{note}
- 如果单位坠落到一个其不能移动的区域上时，会使用原本的游戏逻辑
```

### 切换侵略模式（ *[New Feature] Aggressive Stance (auto target buildings) #1464 by Aephiex* ）

在 `rulesmd.ini` 之中：

```ini
[General]                                    ; 全局通用设置
EnableAggressiveStance=no                    ; 布尔值，是否全局启用该功能，只有该值设置为是才会启用下面的功能

[SOMETECHNO]                                 ; 任意步兵、车辆、飞机或建筑
AggressiveStance=no                          ; 布尔值，单位默认的侵略模式状态
AggressiveStance.Togglable=                  ; 布尔值，单位是否能够切换侵略模式状态
AggressiveStance.Exempt=no                   ; 布尔值，单位是否能够不受侵略模式影响
VoiceEnterAggressiveStance=-1                ; sound条目，进入侵略模式状态时单位会发出的声音
VoiceExitAggressiveStance=-1                 ; sound条目，退出侵略模式状态时单位会发出的声音
```

- 拥有快捷键功能，位于 [控制] 面板
- 如果选中的单位中存在部分单位未进入侵略模式，则按下快捷键时会先让这些单位进入侵略模式，只有当所有选中的单位都处在侵略模式时，才会让他们都退出侵略模式
- `AggressiveStance.Togglable` 的默认值为拥有 `Primary` 或 `OpenTopped` 的同时不能是 `Engineer` 或 `Agent`

```{note}
- 在已有目标的情况下，单位不会自动切换目标
- 关于1个开关快捷键：
  - 开关快捷键默认名为 `Aggressive Stance` ，可以在csf中添加名为 `TXT_AGGRESSIVE_STANCE` 和 `TXT_AGGRESSIVE_STANCE_DESC` 的项目来分别重写其在快捷键页面中的选项名称和详细说明
  - 开关时显示的提示信息，可以在csf中添加名为 `MSG:AGGRESSIVE_STANCE_ON` 和 `MSG:AGGRESSIVE_STANCE_OFF` 的项目来分别定义开和关时显示的文本，文本中可以使用 `%i` 以显示切换状态的单位的数量
```

## 2. 由【航味麻酱】制作功能

- 以下为【航味麻酱】制作功能，使用这些功能发生问题时，可以联系他

  > **航味麻酱**，QQ: 1460015544
  >> Github: **[航味麻酱/TaranDahl](https://github.com/TaranDahl)**

### 单位受击事件（ *pr #1313* ）

在 `rulesmd.ini` 之中：

```ini
[AudioVisual]                                ; 视听通用设置
CombatAlert=no                               ; 布尔值，单位受到攻击时是否发出警报，用于解决单位被白嫖致死的问题
CombatAlert.IgnoreBuilding=yes               ; 布尔值，是否无视建筑受伤导致的受击事件（原版已有功能）
CombatAlert.SuppressIfInScreen=yes           ; 布尔值，是否无视当前正处在游戏画面中的受击事件
CombatAlert.Interval=150                     ; 整数型，两次受击事件需要经过多少帧才真正触发一次警报
CombatAlert.SuppressIfAllyDamage=yes         ; 布尔值，是否无视由友军造成伤害导致的受击事件
CombatAlert.MakeAVoice=yes                   ; 布尔值，是否启用在警报雷达事件发生的同时播放声音提示，启用后以下三项才有效
CombatAlert.UseFeedbackVoice=yes             ; 布尔值，是否最优先使用 `VoiceFeedback` 作为声音提示
CombatAlert.UseAttackVoice=yes               ; 布尔值，如果没有 `VoiceFeedback` ，是否次优先使用 `VoiceAttack` 作为声音提示
CombatAlert.UseEVA=yes                       ; 布尔值，如果没有 `VoiceAttack` ，是否最后使用单位自身的 `CombatAlert.EVA` 作为声音提示

[SOMETECHNO]                                 ; 任意步兵、车辆、飞机或建筑
CombatAlert=yes                              ; 布尔值，该类型在受到攻击时是否发出警报，需要 `AudioVisual` 的 `CombatAlert` 为是
CombatAlert.NotBuilding=                     ; 布尔值，判断是否发出警报时，是否将该类型视作非建筑，默认自动判断该建筑是否可以变成车辆
CombatAlert.UseFeedbackVoice=                ; 布尔值，是否最优先使用 `VoiceFeedback` 作为声音提示
CombatAlert.UseAttackVoice=                  ; 布尔值，如果没有 `VoiceFeedback` ，是否次优先使用 `VoiceAttack` 作为声音提示
CombatAlert.UseEVA=                          ; 布尔值，如果没有 `VoiceAttack` ，是否最后使用单位自身的 `CombatAlert.EVA` 作为声音提示
CombatAlert.EVA=EVA_UnitsInCombat            ; EVA条目，该类型使用的EVA警报条目

[SOMEWARHEAD]                                ; 任意弹头
CombatAlert.Suppress=                        ; 布尔值，使用该弹头攻击是否不会触发警报，默认 [Nonprovocative=yes] 或 [Malicious=no] 都会禁用警报
```

### 快捷键选中所有被心控单位（ *pr #1314* ）

- 快捷键功能，位于 [选择] 面板，无ini
- 现在可以在游戏内设置指定快捷键，通过该快捷键选中所有被临时心控的单位（即不包括Ares永控弹头和超武控制）

```{note}
- 关于1个使用快捷键：
  - 使用快捷键默认名为 `Select Captured Units` ，可以在csf中添加名为 `TXT_SELECT_CAPTURED` 和 `TXT_SELECT_CAPTURED_DESC` 的项目来分别重写其在快捷键页面中的选项名称和详细说明
  - 使用时显示的提示信息，可以在csf中添加名为 `MSG:SelectCaptured` 和 `MSG:NothingSelected` 的项目来分别定义有选中单位和未选中单位时显示的文本
```

### 子机返回行为优化（ *pr #1333* ）

在 `rulesmd.ini` 之中：

```ini
[SOMETECHNO]                                 ; 任意带有子机的母舰型单位
Spawner.RecycleRange=-1                      ; 整数型，子机距离母舰多远时会能被回收，为负数时修复多格建筑无法回收的问题，为零时和原版游戏行为相同，为正数时可以远程回收，单位为 lepton（一格为256 lepton）
Spawner.RecycleAnim=                         ; Anim类型，回收时在子机所在位置播一个动画，你可以远程回收并播一个超时空动画
```

### CellSpread增强（ *pr #1334* ）

在 `rulesmd.ini` 之中：

```ini
[SOMEWARHEAD]                                ; 任意弹头
CellSpread.Cylinder=no                       ; 布尔值，计算弹头的影响范围是否使用圆柱形替代原本的球形，部分情况下无效
AffectsInAir=yes                             ; 布尔值，弹头是否影响位于空中的单位（高度高于208 lepton）
AffectsOnFloor=yes                           ; 布尔值，弹头是否影响位于地上的单位
AffectsUnderground=no                        ; 布尔值，（未提交pr功能）弹头是否影响位于地下的单位
```

```{note}
- Ares的 `DamageAirThreshold` 作用是“如果弹头爆炸高度高于该值，才会影响空军”，和本功能没有冲突且独立运作；举例来说，如果使用圆柱形AOE计算但弹头爆在地上并且没有设置Ares的flags，那么照样不会伤害空军
```

### 步兵移动攻击（ *pr #1341* ）

在 `rulesmd.ini` 之中：

```ini
[SOMEINFANTRY]                               ; 任意步兵
FiringByPassMovingCheck=no                   ; 布尔值，步兵开火前是否不检查移动状态，如果为是，JJ步兵会转身朝向目标，而Walk步兵由于移动时必须播放移动序列而只能在每次进入格子时尝试开火，这能解决JJ步兵脚底下有建筑时无法开火的问题，同时可以通过 Ctrl+Shift 移动攻击，即使没有 [OpportunityFire=yes]
```

### 寄生虫返回优化（ *pr #1342* ）

- 仅优化，无ini
- 在原本的游戏中，寄生虫武器在命中时如果敌人已经死了，寄生虫会返回到开火时的位置；如果该位置被其它单位占了，它就会凭空消失；现在它会出现在该位置周围，在地图边缘可能有bug，遇到请反馈

### 建筑Z键路径点（ *pr #1343* ）

在 `rulesmd.ini` 之中：

```ini
[General]                                    ; 全局通用设置
BuildingWaypoint=no                          ; 布尔值，建筑是否可以使用路径点，可能有bug，遇到请反馈
```

### 以圆柱形计算射程（ *pr #1345* ）

在 `rulesmd.ini` 之中：

```ini
[General]                                    ; 全局通用设置
CylinderRangefinding=no                      ; 布尔值，是否使用圆柱形射程计算，全局值（空军原本默认就是圆柱形）

[SOMEWEAPON]                                 ; 任意武器
CylinderRangefinding=                        ; 布尔值，是否使用圆柱形射程计算，默认值为 `General` 中 `AlwaysCylinderRangefinding` 的值
```

### RepairBaseNodes全局设置和遭遇战AI行为增强（ *pr #1350* ，已被公版合并）

在 `rulesmd.ini` 之中：

```ini
[General]                                    ; 全局通用设置
AIFireSale=yes                               ; 布尔值，电脑是否会卖家（原有条件为一段时间不挨打+没有工厂）
AIFireSaleDelay=0                            ; 整数型，初次达到原有的卖家条件后不卖家，经过这么长时间后，再次达到卖家条件才会卖家，单位为帧
AIAllToHunt=yes                              ; 布尔值，电脑是否会发起最后冲锋
GatherWhenMCVDeploy=yes                      ; 布尔值，电脑的MCV部署时是否把其所有部队集结到MCV周围

[Basic]                                      ; 地图基础设置
RepairBaseNodes=no                           ; 布尔值，是否修理节点建筑，会被 `Side` 覆盖（如果填写）
```

### 无炮塔车辆武器冷却时转向（ *pr #1465* ）

在 `rulesmd.ini` 之中：

```ini
[General]                                    ; 全局通用设置
UnitWithoutTurretAlwaysTurnToTarget=false    ; 布尔值，所有无炮塔单位在武器冷却时是否会朝向目标
```

### 同帧发射武器（ *pr #1467* ）

在 `rulesmd.ini` 之中：

```ini
[SOMEWEAPON]                                 ; 任意武器
Burst.NoDelay=no                             ; 布尔值，是否在同一帧发射所有 `Burst` 并无视任何 `BurstDelay`
```

```{note}
- 仅对步兵和车辆有效，对飞机和建筑是无效的
```

### 矿车倒矿流程优化（ *pr #1476* ）

在 `rulesmd.ini` 之中：

```ini
[SOMEUNIT]                                   ; 采矿车辆
HarvesterQuickUnloader=no                    ; 布尔值，矿车是否可以在矿场旁直接倒矿（就像星际和魔兽农民那样），手动倒矿仍然会使用原有的倒矿流程，暂时不考虑支持采矿步兵；超时空矿车在细节上可能跟原版有所不同，`Weeder` 逻辑理论上可以正常工作，这两个遇到问题请反馈
```

### 进入命令不停止路径点（ 暂无pr ）

在 `rulesmd.ini` 之中：

```ini
[General]                                    ; 全局通用设置
StopPlanningOnEnter=yes                      ; 布尔值，下令进入载具/建筑等操作后是否终止路径点
```

### 扫射飞机攻击强制躲避优化（ 暂无pr ）

在 `rulesmd.ini` 之中：

```ini
[General]                                    ; 全局通用设置
StrafingTargetScatter=yes                    ; 布尔值，扫射飞机攻击的目标是否强制躲避
```

### 自动躲避逻辑优化（ 暂无pr ）

- 仅优化，无ini
- 原版游戏有一些效果会强制单位进行躲避，即使它本身没有躲避能力也一样，现在必须满足 `PlayerScatter=yes` 且是玩家单位或AI的 `IQ` 高于 `IQ` -> `Scatter` 或具有升级能力里的 `Scatter` 才会触发躲避。

### 索敌优化（ 暂无pr ）

在 `rulesmd.ini` 之中：

```ini
[General]                                    ; 全局通用设置
AINormalTargetingDelay=                      ; 整数型，单位为帧，默认为 `NormalTargetingDelay` ，间隔越大单位显得越笨，间隔越小性能消耗越高，没有武器的单位将不再进行目标搜索。不确定是否考虑了所有情况，遇到问题请反馈
PlayerNormalTargetingDelay=                  ; 整数型，单位为帧，默认为 `NormalTargetingDelay` ，间隔越大单位显得越笨，间隔越小性能消耗越高，没有武器的单位将不再进行目标搜索。不确定是否考虑了所有情况，遇到问题请反馈
AIGuardAreaTargetingDelay=                   ; 整数型，单位为帧，默认为 `GuardAreaTargetingDelay` ，间隔越大单位显得越笨，间隔越小性能消耗越高，没有武器的单位将不再进行目标搜索。不确定是否考虑了所有情况，遇到问题请反馈
PlayerGuardAreaTargetingDelay=               ; 整数型，单位为帧，默认为 `GuardAreaTargetingDelay` ，间隔越大单位显得越笨，间隔越小性能消耗越高，没有武器的单位将不再进行目标搜索。不确定是否考虑了所有情况，遇到问题请反馈

[SOMETECHNO]                                 ; 任意步兵、车辆、飞机或建筑
AINormalTargetingDelay=                      ; 整数型，单位为帧，默认值为 `General` 中 `AINormalTargetingDelay` 的值，间隔越大单位显得越笨，间隔越小性能消耗越高，没有武器的单位将不再进行目标搜索。不确定是否考虑了所有情况，遇到问题请反馈
PlayerNormalTargetingDelay=                  ; 整数型，单位为帧，默认值为 `General` 中 `PlayerNormalTargetingDelay` 的值，间隔越大单位显得越笨，间隔越小性能消耗越高，没有武器的单位将不再进行目标搜索。不确定是否考虑了所有情况，遇到问题请反馈
AIGuardAreaTargetingDelay=                   ; 整数型，单位为帧，默认值为 `General` 中 `AIGuardAreaTargetingDelay` 的值，间隔越大单位显得越笨，间隔越小性能消耗越高，没有武器的单位将不再进行目标搜索。不确定是否考虑了所有情况，遇到问题请反馈
PlayerGuardAreaTargetingDelay=               ; 整数型，单位为帧，默认值为 `General` 中 `PlayerGuardAreaTargetingDelay` 的值，间隔越大单位显得越笨，间隔越小性能消耗越高，没有武器的单位将不再进行目标搜索。不确定是否考虑了所有情况，遇到问题请反馈
```

### 自动攻击优化（ 暂无pr ）

在 `rulesmd.ini` 之中：

```ini
[General]                                    ; 全局通用设置
AIAttackIronCurtain=no                       ; 布尔值，AI是否攻击铁幕
PlayerAttackIronCurtain=yes                  ; 布尔值，玩家是否攻击铁幕

[CombatDamage]                               ; 全局伤害设置
PlayerReturnFire.Smarter=no                  ; 布尔值，是否优化 `PlayerReturnFire` 的判定，原版游戏会让单位在挨打时无论是否有命令都直接去攻击开火者
```

```{note}
- `PlayerReturnFire.Smarter` 在移动状态时可能存在问题，如果有问题请反馈
```

### 移动不打破超时空锁定（ 暂无pr ）

在 `rulesmd.ini` 之中：

```ini
[SOMETECHNO]                                 ; 任意步兵、车辆或飞机
KeepWarping=no                               ; 布尔值，是否只有切换目标或者本体消失才会打破超时空锁定
KeepWarping.Distance=                        ; 整数型，与目标距离超过该距离的时候会打断超时空锁定，单位为格，默认使用 `CombatDamage` 中 `OpenToppedWarpDistance` 的值
```

### 玩家建筑自动维修（ 暂无pr ）

在 `rulesmd.ini` 之中：

```ini
[General]                                    ; 全局通用设置
PlayerAutoRepair=no                          ; 布尔值，是否无视 `IQ` 使玩家能够自动维修
```

### 高级碾压龟速bug修复（ 暂无pr ）

在 `rulesmd.ini` 之中：

```ini
[SOMEUNIT]                                   ; 只能是车辆
SkipCrushSlowdown=no                         ; 布尔值，是否跳过减速，如果为是则 `CrushSlowdownMultiplier` 无效
```

### 占领建筑EVA优化（ 暂无pr ）

在 `rulesmd.ini` 之中：

```ini
[AudioVisual]                                ; 视听通用设置
EVA.WeCaptureABuilding=                      ; EVA条目，占领敌人建筑时的EVA
EVA.OurBuildingIsCaptured=                   ; EVA条目，建筑被敌人占领时的EVA
```

### 抛射体散布增强（ 暂无pr ）

在 `rulesmd.ini` 之中：

```ini
[SOMEPROJECTILE]                             ; 任意抛体（暂不支持弹道抛体）
BallisticScatter.IncreaseByRange=no          ; 布尔值，散布是否随距离提升，默认检查是否为 [Inviso=yes] 且 [FlakScatter=yes]
BallisticScatter.MinRange=                   ; 浮点型，计算最小散布的距离
BallisticScatter.MaxRange=                   ; 浮点型，计算最大散布的距离
BallisticScatter.Min.InMinRange=             ; 浮点型，距离最小时的散布范围下限，单位为格
BallisticScatter.Min.InMaxRange=             ; 浮点型，距离最小时的散布范围上限，单位为格
BallisticScatter.Max.InMinRange=             ; 浮点型，距离最大时的散布范围下限，单位为格
BallisticScatter.Max.InMaxRange=             ; 浮点型，距离最大时的散布范围上限，单位为格，如果散布范围太大可能会散到射程之外开不出火。VXL会立即再次选择目标，而SHP如果具有开火序列的话就得先播放序列再选择目标
BallisticScatter.Chance=1.0                  ; 浮点型，启用不精准后产生散布的概率
```

### 攻击潜地单位（ 暂无pr ）

在 `rulesmd.ini` 之中：

```ini
[SOMEPROJECTILE]                             ; 任意抛体
AU=no                                        ; 布尔值，是否可以攻击潜地单位

[SOMEWARHEAD]                                ; 任意弹头
PlayAnimUnderground=no                       ; 布尔值，抛体在地下引爆时，引爆动画是否显示
PlayAnimAboveSurface=no                      ; 布尔值，抛体在地下引爆时，引爆动画是否在地面位置显示
```

### 区域警戒优化（ 暂无pr ）

在 `rulesmd.ini` 之中：

```ini
[General]                                    ; 全局通用设置
PlayerGuardModePursuit=yes                   ; 布尔值，对玩家有效，是否追击敌人，为否则会在超过归巢距离（即离开警戒目标多远就该往回跑）后立即触发归巢，为是则必须停下且没在开火才会归巢
PlayerGuardModeGuardRangeMax=16              ; 浮点型，对玩家有效，最大警戒距离，单位：格，当警戒目标为【可移动单位】时，警戒距离（即多远处出现目标就会跑去攻击）等同于 `GuardRange` ，当警戒目标为【空地或建筑】时，警戒距离等于：1.1 × min(GuardRange × 乘数 + 加数, 最大值)
PlayerGuardModeGuardRangeMultiplier=2.0      ; 浮点型，对玩家有效，警戒距离乘数
PlayerGuardModeGuardRangeAddend=0            ; 浮点型，对玩家有效，警戒距离加数，单位：格
PlayerGuardStationaryStray=-1                ; 浮点型，对玩家有效，警戒目标为【空地或建筑】时的归巢距离，单位：格
AIGuardModePursuit=yes                       ; 布尔值，对电脑有效，是否追击敌人，为否则会在超过归巢距离（即离开警戒目标多远就该往回跑）后立即触发归巢，为是则必须停下且没在开火才会归巢
AIGuardModeGuardRangeMax=16                  ; 浮点型，对电脑有效，最大警戒距离，单位：格，当警戒目标为【可移动单位】时，警戒距离（即多远处出现目标就会跑去攻击）等同于 `GuardRange` ，当警戒目标为【空地或建筑】时，警戒距离等于：1.1 × min(GuardRange × 乘数 + 加数, 最大值)
AIGuardModeGuardRangeMultiplier=2.0          ; 浮点型，对电脑有效，警戒距离乘数
AIGuardModeGuardRangeAddend=0                ; 浮点型，对电脑有效，警戒距离加数，单位：格
AIGuardStationaryStray=-1                    ; 浮点型，对电脑有效，警戒目标为【空地或建筑】时的归巢距离，单位：格

[SOMETECHNO]                                 ; 任意步兵或单位
PlayerGuardModePursuit=                      ; 布尔值，对玩家单位有效，是否追击敌人
PlayerGuardModeStray=                        ; 浮点型，对玩家单位有效，警戒目标为【可移动单位】时的归巢距离，默认值为 `General` 中 `GuardModeStray` 的值
PlayerGuardModeGuardRangeMultiplier=         ; 浮点型，对玩家单位有效，警戒距离乘数，默认值为 `General` 中 `PlayerGuardModeGuardRangeMultiplier` 的值
PlayerGuardModeGuardRangeAddend=             ; 浮点型，对玩家单位有效，警戒距离加数，单位：格，默认值为 `General` 中 `PlayerGuardModeGuardRangeAddend` 的值
PlayerGuardStationaryStray=                  ; 浮点型，对玩家单位有效，警戒目标为【空地或建筑】时的归巢距离，单位：格，默认值为 `General` 中 `PlayerGuardStationaryStray` 的值，当且仅当为-1时使用响应距离作为归巢距离
AIGuardModePursuit=                          ; 布尔值，对电脑单位有效，是否追击敌人
AIGuardModeStray=                            ; 浮点型，对电脑单位有效，警戒目标为【可移动单位】时的归巢距离，默认值为 `General` 中 `GuardModeStray` 的值
AIGuardModeGuardRangeMultiplier=             ; 浮点型，对电脑单位有效，警戒距离乘数，默认值为 `General` 中 `AIGuardModeGuardRangeMultiplier` 的值
AIGuardModeGuardRangeAddend=                 ; 浮点型，对电脑单位有效，警戒距离加数，单位：格，默认值为 `General` 中 `AIGuardModeGuardRangeAddend` 的值
AIGuardStationaryStray=                      ; 浮点型，对电脑单位有效，警戒目标为【空地或建筑】时的归巢距离，单位：格，默认值为 `General` 中 `AIGuardStationaryStray` 的值，当且仅当为-1时使用响应距离作为归巢距离
```

```{note}
- `General` 中的 `GuardModeStray` 是原有标签
```

### 工程师自动开火（ 暂无pr ）

在 `rulesmd.ini` 之中：

```ini
[SOMEINFANTRY]                               ; 任意步兵
Engineer.CanAutoFire=no                      ; 布尔值，工程师是否会自动开火，目前只能自动治疗友军
```

### 可强制进入坦克碉堡（ 暂无pr ）

在 `rulesmd.ini` 之中：

```ini
[SOMEUNIT]                                   ; 只能是车辆
BunkerableAnyWay=no                          ; 布尔值，没炮塔或 [SpeedType=Hover] 的坦克是否允许进入坦克碉堡（[Locomotor=Hover] 的单位和被寄生的单位仍然不允许进入，而没炮塔的坦克会在碉堡里转身，除非具有全向开火）
```

### 矿车区域警戒（ 暂无pr ）

在 `rulesmd.ini` 之中：

```ini
[SOMEUNIT]                                   ; 采矿车辆
Harvester.CanGuardArea=no                    ; 布尔值，矿车进行区域警戒时是否正常GuardArea而非去采矿
```

### 钻地Locomotor自定义（ 暂无pr ）

在 `rulesmd.ini` 之中：

```ini
[SOMEUNIT]                                   ; 钻地车辆
DigStartROT=-1                               ; 整数型，开始钻地时低头的ROT，抬头总时间是64/DigStartROT帧，为非正数时使用默认算法
DigInSpeed=-1                                ; 整数型，往下钻时的速度，单位Lepton，为非正数时使用默认算法
DigOutSpeed=-1                               ; 整数型，往上钻时的速度，单位Lepton，为非正数时使用默认算法
DigEndROT=-1                                 ; 整数型，结束钻地时抬头的ROT，抬头总时间是64/DigEndROT帧，为非正数时使用默认算法
```

### 飞机Locomotor自定义（ 暂无pr ）

在 `rulesmd.ini` 之中：

```ini
[SOMEAIRCRAFT]                               ; 任意飞机
FlightClimb=-1                               ; 整数型，爬升时的速度，一旦设置所有爬升都用这个速度，-1使用默认算法
FlightCrash=-1                               ; 整数型，下降时的速度，一旦设置所有下降都用这个速度，-1使用默认算法
```

### 改变地图光照弹头（ 暂无pr ）

在 `rulesmd.ini` 之中：

```ini
[SOMEWARHEAD]                                ; 任意弹头
LightChanging=no                             ; 布尔值，是否启用光照弹头（改变的是默认光照，不会放个核弹就变回去了，且应该会比核弹性能好一点，但是仍然不应该高频调用）
SetAmbientLight=-1                           ; 整数型，光照强度，负数使用当前值（参考地图光照参数）
SetAmbientRed=-1                             ; 整数型，红光强度，负数使用当前值（参考地图光照参数）
SetAmbientGreen=-1                           ; 整数型，绿光强度，负数使用当前值（参考地图光照参数）
SetAmbientBlue=-1                            ; 整数型，蓝光强度，负数使用当前值（参考地图光照参数）
```

### 碾压死亡增强（ 暂无pr ）

在 `rulesmd.ini` 之中：

```ini
[CombatDamage]                               ; 全局伤害设置
UseGlobalDeathWeaponDamage=no                ; 布尔值，无死亡武器且无武器单位是否使用全局死亡武器的Damage作为死亡武器伤害，默认使用的是血量/2
FireDeathWeaponOnCrushed=no                  ; 布尔值，被碾压死亡是否触发死亡武器

[General]                                    ; 全局通用设置
CrushBuildingOnAnyCell=no                    ; 布尔值，是否建筑的任意一格都可以被碾压，默认只有中心可以被碾压

[AudioVisual]                                ; 视听通用设置
NonVehExplodeOnDestroy=no                    ; 布尔值，非车辆单位通过Destroy方法死亡时是否触发Explosion和DeathAnim，哪些死亡方式调用了Destroy方法有待检查，但碾压是其中之一

[SOMETECHNO]                                 ; 任意步兵、车辆、飞机或建筑
ExplodeOnDestroy=                            ; 布尔值，通过Destroy方法死亡时是否触发Explosion和DeathAnim，车辆单位默认为是，其余类型默认为 `AudioVisual` 中 `NonVehExplodeOnDestroy` 的值
FireDeathWeaponOnCrushed=                    ; 布尔值，被碾压死亡是否触发死亡武器，默认为 `CombatDamage` 中 `FireDeathWeaponOnCrushed` 的值
```

### 集结点增强（ 暂无pr ）

在 `rulesmd.ini` 之中：

```ini
[General]                                    ; 全局通用设置
RallyPointOnTechno=no                        ; 布尔值，是否能在步兵、车辆、飞机或建筑上设置集结点，默认情况下只有克隆缸可以
RallyPointForceMove=no                       ; 布尔值，往单位上设置集结点时是否不需要按住Alt就能设置
RallyPointAreaGuard=no                       ; 布尔值，产出的单位是否默认设置AreaGuard任务，如果有集结点则会跟随目标或保卫目标区域，矿车会去采矿

[SOMEBUILDING]                               ; 任意建筑
JustHasRallyPoint=no                         ; 布尔值，该建筑是否可以设置集结点

[SOMEAIRCRAFT]                               ; 任意飞机
IgnoreRallyPoint=no                          ; 布尔值，该飞机是否无视机场集结点
```

```{note}
- 船厂暂不支持在步兵、车辆、飞机或建筑上设置集结点
- 建筑即使能够设置集结点，也不一定有实际作用
```

### 重工顺产优化（ 暂无pr ）

在 `rulesmd.ini` 之中：

```ini
[SOMETECHNO]                                 ; 任意步兵、车辆、飞机或建筑
ExitCoord=                                   ; XYZ坐标，请写完整，（原有功能-增强）设置在建筑上时，产出的单位将会被默认放置在该位置，设置在产出单位上时，则会覆盖建筑的

[SOMEBUILDING]                               ; 任意建筑
JumpjetExitCoord=                            ; XYZ坐标，请写完整，产出的具有 [Locomotor=Jumpjet] 的单位将会被默认放置在该位置
```

```{note}
- 如果是战车工厂使用，则需要其有 `WeaponsFactory=no`
```

### 导弹子机发射位置拓展（ 暂无pr ）

在 `rulesmd.ini` 之中：

```ini
[SOMETECHNO]                                 ; 任意步兵、车辆、飞机或建筑
MissileSpawnUseOtherFLHs=no                  ; 布尔值，是否能够使用除了Burst为0和1以外的其它FLH，进而通过 `XXXFLH.BurstN` 让它们使用其它FLH，导弹将会出现在那些位置上
```

```{note}
- 开启这个选项后就不要使用 `SecondSpawnOffset` 了
```

### 位移武器（ 暂无pr ）

在 `rulesmd.ini` 之中：

```ini
[SOMEWEAPON]                                 ; 任意 `LimboLaunch=yes` 的武器
UnlimboDetonate=no                           ; 布尔值，是否在抛射体引爆时将被 `LimboLaunch=yes` 藏起来的单位拿出来，如果单位不是由 `LimboLaunch=yes` 藏起来的则不会生效，最终效果类似于单位随抛体移动过去
UnlimboDetonate.Force=no                     ; 布尔值，是否无视障碍而强制将单位在抛射体引爆处拿出来，为否且目标位置被阻挡则会在附近拿出来
```

```{note}
- `UnlimboDetonate` 不能和 `Parasite` 一起使用
```

### 自动攻击围墙（ 暂无pr ）

在 `rulesmd.ini` 之中：

```ini
[General]                                    ; 全局通用设置
PlayerDestroyWalls=no                        ; 布尔值，玩家单位是否自动攻击围墙
DestroyOwnerlessWalls=no                     ; 布尔值，自动攻击围墙的单位是否将所有非友军的围墙都作为目标，包括无所属方的和三家中立的
```

```{note}
- 同时修复了攻击围墙时，有时墙被拆掉后仍然不会停火的问题
```

### 玩家队友AI智力恢复（ 暂无pr ）

在 `rulesmd.ini` 之中：

```ini
[General]                                    ; 全局通用设置
AIAngerOnAlly=yes                            ; 布尔值，是否允许AI向友方施加仇恨，用于修复玩家的队友AI会表现非常被动、只有在敌人进家之后才会开始正常行动的问题
```

```{note}
- 是否存在副作用需要测试
```

### Jumpjet智力恢复（ 暂无pr ）

- 仅优化，无ini
- 在原版游戏中，给移动中的Jumpjet步兵下令攻击时，它会首先停止移动；如果连续下令，那么它将在原地抽搐无法前进；这里通过跳过该停止移动函数来避免这个问题；除此之外，如果Jumpjet单位攻击目标在射程范围内，则会停止移动

```{note}
- 是否存在副作用需要测试
```

### 弹头杀伤矿石（ 暂无pr ）

在 `rulesmd.ini` 之中：

```ini
[SOMEWARHEAD]                                ; 任意弹头
ReduceTiberium=no                            ; 布尔值，是否伤害矿石（原版 `Tiberium` 用于控制弹头是否能杀伤矿石，但只有具有 `ChainReaction` 的矿石会被伤害，新标签可用于伤害任何矿石，受到伤害的格子里矿石的量将会减少抛射体伤害/10，伤害范围使用CellSpread，对矿石的伤害不会因为远离爆心而递减）
```

### 16号脚本巡逻至路径点增强（ 暂无pr ）

- 现在可以通过Phobos攻击和移动脚本类似的方式自动推算一个格子来代替路径点，单位会按照原有的逻辑巡逻过去，使用**小于0**的脚本参数会自动使用新逻辑，参数 `-n` 的解析方式如下（先将其去掉负号，并转换为**二进制数**得到 `ABCDDDEEEEEEEE` ，相反的，你可以通过计算器的程序员模式先将二进制数写出，再转换成十进制数）
  - `-n` 的二进制1-8位 EEEEEEEE
    > 目标类型，填 `AITargetType` 中值的索引或 `TargetType#` 的类型，具体是索引还是类型根据a4决定，具体参考Phobos攻击和移动脚本中n的写法（由于只有8位，所以没法填超过256的索引，不过256应该也够用了）
  - `-n` 的二进制9-11位 DDD
    > 目标选择优先级计算算法，0 - 距离近且高仇恨单位优先，1 - 距离远且高仇恨，2 - 距离近，3 - 距离远，4 - 更能保持作战方存活的优先（具体来说就是基地和MCV最高，其次战车工厂，然后其它工厂，再次其它 `KeepAlive` 的单位，最后是其它不 `KeepAlive` 的单位，若同一类型有多个，优先选择距离近的）
  - `-n` 的二进制第12位 C
    > 选择友军还是敌军，0 - 敌军，1 - 友军
  - `-n` 的二进制第13位 B
    > 选择目标使用 `AITargetType` 还是 `TargetType#` ，两者的区别参考Phobos已有的说明书，0 - `TargetType#` ，1 - `AITargetType`
  - `-n` 的二进制第14位 A
    > 是否需要目标可以被小队首领攻击，0 - 不需要，1 - 需要

In `aimd.ini`:

```ini
[SOMESCRIPTTYPE]                             ; 任意脚本类型
X=16,-n                                      ; 脚本
```

```{note}
- 没有仔细检查16号脚本的细节，目前可能有不小的bug，小心使用，遇到问题请反馈
```

### 新的Phobos脚本目标选项（ 暂无pr ）

- 增加了 *TargetType#* 可选类型：

| *TargetType#* | 其代表的类型 |
|:-------------:|:------------:|
|     *37*      | 陆地上的工厂 |
|     *38*      | 陆地上的建筑 |
|     *39*      | 陆地上的单位 |

### Ctrl+Alt跟随目标本身（ 暂无pr ）

在 `rulesmd.ini` 之中：

```ini
[General]                                    ; 全局通用设置
FollowTargetSelf=no                          ; 布尔值，是否只跟随单位本体而不是自动前往被跟随单位的目的地
```

### 矿车找矿算法优化（ 暂无pr ）

在 `rulesmd.ini` 之中：

```ini
[General]                                    ; 全局通用设置
HarvesterScanAfterUnload=no                  ; 布尔值，倒矿之后是否找一次矿，如果距离比回家之前记住的位置更近则会前往新的这个位置而非之前记住的位置
```

### 隐身单位丢失引用修复（ 暂无pr ）

- 仅优化，无ini
- 原本游戏中，单位隐身时会声明指针无效，这导致的问题包括但不限于子机导弹丢失所属无法为本体提供经验，现在把这部分代码跳过了

```{note}
- 可能会导致其它问题，尤其是联机情况下，遇到请反馈
```

### 强制不同帧索敌（ 暂无pr ）

在 `rulesmd.ini` 之中：

```ini
[General]                                    ; 全局通用设置
DistributeTargetingFrame=no                  ; 布尔值，是否强制所有单位在不同帧索敌；原本游戏中，如果你在同一帧创建了大量单位（比如一个初始摆满了单位的战役地图），那么它们总是以一个相同的间隔索敌，并导致游戏周期性卡顿，现在可以通过设置此项强制它们分散到不同帧进行索敌
DistributeTargetingFrame.AIOnly=yes          ; 布尔值，是否只有AI的单位遵循 `DistributeTargetingFrame`

[SOMETECHNO]                                 ; 任意步兵、车辆、飞机或建筑
DistributeTargetingFrame=                    ; 布尔值，是否强制该类型单位在不同帧索敌，默认值为 `General` 中 `DistributeTargetingFrame` 的值
```

```{note}
- 这会导致单位索敌间隔随机提升，如果你真的有一个索敌间隔很短的单位的话，那它可能会受到显著影响
```

### 搜索移动优化（ 暂无pr ）

在 `rulesmd.ini` 之中：

```ini
[General]                                    ; 全局通用设置
AttackMove.StopWhenTargetAcquired=           ; 布尔值，所有单位在搜索移动时是否会在获取目标后停下，该值为否时即恢复原版行为，如果不填，则使用每个单位本身的 `OpportunityFire` 取反作为默认值
AttackMove.IgnoreWeaponCheck=no              ; 布尔值，是否在判断单位能否搜索移动时不检查其有无武器

[SOMETECHNO]                                 ; 任意步兵、车辆、飞机或建筑
AttackMove.StopWhenTargetAcquired=           ; 布尔值，该单位在搜索移动时是否会在获取目标后停下，默认值为 `General` 中  `AttackMove.StopWhenTargetAcquired` 的值
AttackMove.PursuitTarget=no                  ; 是否在获取目标时转而向目标移动。这主要是用于基洛夫、狂兽人之类近战单位
AttackMove.Follow=no                         ; 布尔值，用于辅助单位的特殊设置，是否在执行搜索移动时选择最近的正在搜索移动的单位并跟随它，以此替换搜索移动，选择范围同GuardArea响应范围
AttackMove.Follow.IncludeAir=no              ; 布尔值，是否在 `AttackMove.Follow` 搜索时包含空军
```

```{note}
- 单位搜索移动时自动获取目标的范围是GuardRange，但自动失去目标的范围是武器射程
- `AttackMove.StopWhenTargetAcquired` 的作用：
  1. 使步兵可以正确运用 Ctrl+Shift 攻击建筑
  2. 使 `Locomotor=Jumpjet` 的步兵、车辆可以使用 Ctrl+Shift 在索敌时停下而非骑脸
  3. 使有炮塔单位不能无视 `OpportunityFire` 进行移动攻击
```

### 机场产Jumpjet （ 暂无pr ）

在 `rulesmd.ini` 之中：

```ini
[SOMETECHNO]                                 ; 任意步兵、车辆、飞机或建筑
ThisIsAJumpjet=                              ; 任意步兵、车辆、飞机或建筑，这个飞机出厂时变成什么单位
ImAJumpjetFromAirport=no                     ; 布尔值，这个单位是否是被一个飞机“变”出来的
```

```{note}
- 你需要做的是：
  1. 注册一架飞机 A ，不要将其添加到 `PadAircraft` 中，并写上 `AirportBound=no` ，在 A 上写 `ThisIsAJumpjet=B`
  2. 注册一艘 Jumpjet 载具 B ，在 B 上写 `ImAJumpjetFromAirport=yes` ；如果需要限制建造数量，可以使用建造限制组
  3. 在机场上写 `WeaponsFactory=no` ；原本这类车厂基本上是残废的，但你可以借助我制作的其它功能让它们变得正常
- 最终效果：
  - 当你建造飞机 A 时，机场会刷出一个 B 来；建造时间、造价等都是按 A 的来，而刷出位置、被克隆等都是按 B 的来
- 副作用：
  - A 和 B 理论上可以是任意类型的单位。不过目前这个功能的设计目标是机场产 Jumpjet ，对于其它类型未必能完美运行
```

### 沉船增强（ 暂无pr ）

在 `rulesmd.ini` 之中：

```ini
[SOMEUNIT]                                   ; 只能是车辆
Sinkable=                                    ; 布尔值，在水面上被摧毁时是否无视其它因素触发沉没，留空则使用原本的判定规则
SinkSpeed=5                                  ; 整数型，沉没时每帧下沉的距离，单位Lepton
```

```{note}
- 沉没时间取决于沉没速度，单位沉没到地下 400 Lepton 后才会完全被移除
- 体积较大的vxl船只在沉没时可能导致绘制错误使游戏崩溃，使用 `Sinkable=no` 以解决这一问题
```

### 波能拼图（ 暂无pr ）

在 `rulesmd.ini` 之中：

```ini
[SOMEWEAPON]                                 ; 任意武器
ResetGattlingValue=no                        ; 布尔值，开火后是否清空加特林计数
AddtionalDamage.GattlingValue=no             ; 布尔值，武器是否额外附加正比于加特林计数的伤害
AddtionalDamage.GattlingValue.Mult=1.0       ; 浮点型，额外伤害是加特林计数的多少倍
```

```{note}
- 仅有这些功能你大概是没法拼出来一个波能的。剩下的拼图在WIC里
```

### Jumpjet速度类型（ 暂无pr ）

在 `rulesmd.ini` 之中：

```ini
[SOMETECHNO]                                 ; 任意 `Locomotor=Jumpjet` 的步兵、车辆
JumpjetSpeedType=3                           ; 整数型，Winged是4，Hover是3
```

```{note}
- 原本游戏中JJ硬编码使用Hover速度类型判断格子是否可以前往。这主要影响JJ步兵，使得它们无法停在建筑上或悬崖上，现在你可以把它改成Winged以解决这一问题，需要注意的是：
  1. 似乎这个改动不会影响JJ载具，不过你可以直接给JJ载具设置Winged速度类型来规避这一问题，目前没有发现什么明显的副作用
  2. 如果你不使用这个功能，即使你直接给JJ步兵设置Winged速度类型也没用，而且还会导致它无法正确从未设置路径点的兵营里出来、无法被Ares投放超武投放之类的愚蠢问题
  3. 这个功能不会影响JJ的速度
- `JumpjetSpeedType` 可以设置为其它值，请自行查阅yrpp，不保证不会出现意料之外的问题
```

### 建筑TypeSelect（ 暂无pr ）

在 `rulesmd.ini` 之中：

```ini
[General]                                    ; 全局通用设置
BuildingTypeSelectable=no                    ; 布尔值，建筑是否可以使用TypeSelect（即按t选中同类）
```

### 同帧指令上限优化（ 暂无pr ）

- 仅优化，无ini
- 同一帧只能对最多128个单位下达指令的限制现在被扩大到了无上限，且能够在联机下生效

```{note}
- 路径点模式下仍然被限制，这可能在将来会改动
- 如果仍存在部分指令无法超过128的限制，请反馈
```

### 集结点寻路优化（ 暂无pr ）

在 `rulesmd.ini` 之中：

```ini
[SOMEBUILDING]                               ; 只能是建筑
RallySpeedType=                              ; 整数型，Winged是4
RallyMovementZone=                           ; 整数型，Fly是9
```

```{note}
- `RallySpeedType` 和 `RallyMovementZone` 可以设置为其它值，请自行查阅yrpp
```

### 渗透关闭小地图（ 暂无pr ）

在 `rulesmd.ini` 之中：

```ini
[SOMEBUILDING]                               ; 任意 `SpyEffect.Custom=yes` 的建筑
SpyEffect.RadarJamDuration=0                 ; 整数型，单位为帧，建筑被渗透时关闭小地图多久
```

## 3. 由【绯红热茶】制作功能

- 以下为【绯红热茶】制作功能，使用这些功能发生问题时，可以联系他

  > **緋紅熱茶**，QQ: 335958461
  >> Github: **[绯红热茶/CrimRecya](https://github.com/CrimRecya)**

### 新的数显类型和显示方式（ *pr #1287* ）

- 增加了 `InfoType` 可选类型：

| 类型            | 简述                     | 计数   | 条件                 | 说明                                                                                                            |
|:----------------|:-------------------------|:-------|:---------------------|:----------------------------------------------------------------------------------------------------------------|
| *ROF*           | 开火间隔计时器           | 倒计时 | 需要存在主武器       | 单位为帧，在未开火时，会使用【主武器】的ROF作为上限，而在第一次开火后，会使用每次开火的武器ROF或Burstdelay      |
| *Reload*        | 弹药装填计时器           | 倒计时 | 需要使用弹药逻辑     | 单位为帧，满弹药时值为0，不支持飞机弹药                                                                         |
| *SpawnTimer*    | 子机重生计时器           | 倒计时 | 需要使用子机逻辑     | 单位为帧，无子机被摧毁时值为0，有子机被摧毁时会选择最快重生（最早被摧毁）的子机显示其复活剩余时间               |
| *GattlingTimer* | 盖特进度计数器           | 计数器 | 需要使用盖特逻辑     | 当前盖特计数在当前盖特阶段的值                                                                                  |
| *ProduceCash*   | 油井生产计时器           | 倒计时 | 需要使用油井逻辑     | 单位为帧，距离下一次获得收益的时间                                                                              |
| *PassengerKill* | 删除载员计时器           | 倒计时 | 需要使用删除载员逻辑 | 单位为帧，距离下一次删除载员的时间                                                                              |
| *AutoDeath*     | 自动死亡计时器           | 倒计时 | 需要使用自动死亡逻辑 | 优先显示自动死亡计时器的值，单位为帧，若未设置，则再显示弹药量，若仍未设置，则不再判断Techno存在条件并不显示    |
| *SuperWeapon*   | 建筑超武计时器           | 倒计时 | 需要使用建筑超武     | 单位为帧，最优先显示建筑的 `SuperWeapon` ，若没有则显示 `SuperWeapon2` ，若还没有则显示 `SuperWeapons` 的第一项 |
| *IronCurtain*   | 铁幕剩余时间计时器       | 倒计时 | 需要处在铁幕状态下   | 单位为帧，铁幕的剩余时间                                                                                        |
| *TemporalLife*  | 超时空武器剩余时间计时器 | 倒计时 | 需要被超时空武器锁定 | 单位为帧，显示在目标的身上，距离被传送走还剩多久                                                                |

在 `rulesmd.ini` 之中：

```ini
[SOMEDIGITALDISPLAYTYPE]                     ; 任意Phobos数显
InfoType=                                    ; InfoType类型
Shape.PercentageFrame=no                     ; 布尔值，为是且有 `Shape` 时启用，启用时忽略 `Percentage` 和 `HideMaxValue` 并自动计算后绘制 `Shape` 中当前百分比所对应的一帧（简单来说，可以由 `Shape` 绘制一套【进度条】图像， `InfoType` 对应当前值越小则 `Shape` 帧号越小，采用4舍5入）
VisibleInSpecialState=yes                    ; 布尔值，在铁幕状态下时或被超时空武器锁定时是否显示数显
```

### 武器使用时保持合适距离（ *pr #1288* ）

在 `rulesmd.ini` 之中：

```ini
[SOMEWEAPON]                                 ; 任意武器
KeepRange=0                                  ; 浮点型，实际读取绝对值，为零关闭，正数会尽可能保持在这个距离之外，负数会尽可能贴近到这个距离以内（对于多Burst武器，检测敏感度较低）
KeepRange.AllowAI=no                         ; 布尔值，保持距离功能是否对AI有效
KeepRange.AllowPlayer=no                     ; 布尔值，保持距离功能是否对玩家有效
```

```{note}
- 该射程与最大最小射程之间的区间需要有至少1.0（步兵为2.0最佳），否则容易被判定为无法开火而直接移动过去
```

### 抛射体发射前直线地形检查（ *pr #1291* ）

在 `rulesmd.ini` 之中：

```ini
[SOMEPROJECTILE]                             ; 任意抛体
SubjectToGround=no                           ; 布尔值，单位开火前是否会进行地形检查防止抛体穿过地下，只是检查，不会实际引爆抛体
```

### 重置Burst计数（ *pr #1292* ）

在 `rulesmd.ini` 之中：

```ini
[General]                                    ; 全局通用设置
RecountBurst=no                              ; 布尔值，所有单位在更换使用的武器时，或保持无目标状态一段时间（30帧和上一次发射的武器的 `ROF` 取较大值）后，是否重置当前的Burst计数

[SOMETECHNO]                                 ; 任意步兵、车辆、飞机或建筑
RecountBurst=                                ; 布尔值，当前单位在更换使用的武器时，或保持无目标状态一段时间（30帧和上一次发射的武器的 `ROF` 取较大值）后，是否重置当前的Burst计数，默认值为 `General` 中 `RecountBurst` 的值
```

### 新增切割抛体（ *pr #1293* ）

在 `rulesmd.ini` 之中：

```ini
[SOMEPROJECTILE]                             ; 弹道抛体（不和原版四类抛体共存）
Trajectory=                                  ; Trajectory类型，以下为【Engrave】（【不需要】武器上的参数，只会在刚开火时触发步兵攻击帧，且如果可被拦截会很诡异，不会对空，不影响炮塔旋转，建议速度为40）
Trajectory.Speed=100.0                       ; 浮点型，弹道抛体的速度，此值定义的是切割过程的水平移动速度（最高速度限制在128）
Trajectory.Engrave.ApplyRangeModifiers=no    ; 布尔值，抛体的 `Trajectory.Engrave.TheDuration` 的计算（包括为零时的自动计算）是否会受到射程AE的影响
Trajectory.Engrave.SourceCoord=0,0           ; FL坐标，请写完整，抛体会从目标的这个相对坐标开始切割，即切割线段的起点坐标，H坐标会吸附地面，特殊值为0,0，指从开火位置开始
Trajectory.Engrave.TargetCoord=0,0           ; FL坐标，请写完整，抛体会朝目标的这个相对坐标进行切割，即切割线段的指向坐标，H坐标会吸附地面
Trajectory.Engrave.MirrorCoord=yes           ; 布尔值，切割激光的 `Trajectory.Engrave.SourceCoord` 和 `Trajectory.Engrave.TargetCoord` 中的L方向是否会随当前的 `Burst` 计数镜像翻转
Trajectory.Engrave.UseDisperseCoord=no       ; 布尔值，切割激光的发射位置是否使用扩散它的上级扩散抛体的发射位置替换固定位置，需要上级抛体拥有 `Trajectory.Disperse.RecordSourceCoord`
Trajectory.Engrave.TheDuration=0             ; 整数型，切割过程的持续时间，如果为非正数则会根据 `Trajectory.Engrave.SourceCoord` 和 `Trajectory.Engrave.TargetCoord` 自动计算时间，此时 `Trajectory.Engrave.TargetCoord` 可以视作是切割线段的终点坐标
Trajectory.Engrave.IsLaser=yes               ; 布尔值，是否绘制切割激光
Trajectory.Engrave.IsSupported=no            ; 布尔值，切割激光是否会更亮更粗，需要 `Trajectory.Engrave.IsHouseColor` 或 `Trajectory.Engrave.IsSingleColor` 为是才有效
Trajectory.Engrave.IsHouseColor=no           ; 布尔值，切割激光是否使用阵营颜色，启用后以下4项无效，启用后支持激光粗细
Trajectory.Engrave.IsSingleColor=no          ; 布尔值，切割激光是否只用内部颜色，启用后 `Trajectory.Engrave.LaserOuterColor` 和 `Trajectory.Engrave.LaserOuterSpread` 无效，启用后支持激光粗细
Trajectory.Engrave.LaserInnerColor=0,0,0     ; RGB颜色，请写完整，切割激光的中心颜色
Trajectory.Engrave.LaserOuterColor=0,0,0     ; RGB颜色，请写完整，切割激光的外围颜色
Trajectory.Engrave.LaserOuterSpread=0,0,0    ; RGB颜色，请写完整，切割激光的扩散颜色
Trajectory.Engrave.LaserThickness=3          ; 整数型，切割激光的粗细程度，需要 `Trajectory.Engrave.IsHouseColor` 或 `Trajectory.Engrave.IsSingleColor` 为是才有效
Trajectory.Engrave.LaserDuration=1           ; 整数型，切割激光的持续时间
Trajectory.Engrave.LaserDelay=1              ; 整数型，切割激光每隔这么多帧才绘制一次
Trajectory.Engrave.DamageDelay=2             ; 整数型，切割激光每隔这么多帧才造成一次伤害
```

```{note}
- 为了视觉效果，最好不要设置让此抛体可被拦截
```

### 直线抛体增强（ *pr #1294* ）

在 `rulesmd.ini` 之中：

```ini
[SOMEPROJECTILE]                             ; 弹道抛体（不和原版四类抛体共存）
Trajectory=                                  ; Trajectory类型，以下为【Straight】
Trajectory.Speed=100.0                       ; 浮点型，弹道抛体的速度，此值定义的是抛体的速度（最高速度无限制）
Trajectory.Straight.ApplyRangeModifiers=no   ; 布尔值，（原有功能-增强）抛体 `Trajectory.Straight.DetonationDistance` 和 `Trajectory.Straight.EdgeAttenuation` 的计算是否会受到射程AE的影响
Trajectory.Straight.DetonationDistance=0.4   ; 浮点型，（原有功能-不变）抛体在距离目标多远距离内就会引爆
Trajectory.Straight.TargetSnapDistance=0.5   ; 浮点型，（原有功能-不变）抛体引爆时，当前目标在多近的距离内弹头会吸附过去
Trajectory.Straight.PassThrough=no           ; 布尔值，（原有功能-增强）启用时，若 `Trajectory.Straight.DetonationDistance` 为正则抛体在距离【发射者】这个值的距离的位置引爆，为负则抛体在穿过【目标点】这个值的绝对值的位置引爆，为零视为无穷远
Trajectory.Straight.PassDetonate=no          ; 布尔值，启用穿透伤害，即抛体每隔一段时间在抛体所在的位置引爆一个弹头
Trajectory.Straight.PassDetonateWarhead=     ; Warhead类型，穿透伤害使用的弹头
Trajectory.Straight.PassDetonateDamage=0     ; 整数型，穿透伤害撞击伤害的伤害量
Trajectory.Straight.PassDetonateDelay=1      ; 整数型，穿透伤害每隔这么多帧才能触发一次，最低为1
Trajectory.Straight.PassDetonateInitialDelay=0; 整数型，穿透伤害在抛体发射后多少帧第一次触发，即穿透伤害触发的初始延迟
Trajectory.Straight.PassDetonateLocal=no     ; 布尔值，穿透伤害的每帧引爆的弹头和最终引爆本体的弹头是否位于【地面】高度，同时也影响在使用 `Trajectory.Straight.ConfineAtHeight` 时抛体的垂直方向速度将不受限制（如果想在桥上炸，可以改用 `Trajectory.Straight.ConfineAtHeight` 并将其设置为1）
Trajectory.Straight.LeadTimeCalculate=no     ; 布尔值，抛体在瞄准时是否计算目标的提前量，计算目标的提前量会在开火时延迟1帧发射且增加性能消耗，同时若抛体的速度过低，则会无法生效
Trajectory.Straight.OffsetCoord=0,0,0        ; FLH坐标，请写完整，抛体会瞄准目标的这个相对坐标进行攻击，支持在此基础上启用随机散布
Trajectory.Straight.RotateCoord=0            ; 浮点型，是否按照武器的 `Burst` 在以 `Trajectory.Straight.OffsetCoord` 为角平分线的角度内旋转抛体发射方向，为0代表不启用该逻辑（负值会反转旋转方向）
Trajectory.Straight.MirrorCoord=yes          ; 布尔值，抛体在瞄准目标相对坐标进行攻击前，如果发射者开火时当前武器的 `Burst` 数为偶数，则 `Trajectory.Straight.OffsetCoord` 中的L会镜像翻转，同时 `Trajectory.Straight.RotateCoord` 计算的旋转方向也会反转，每一侧的每个相邻抛体之间的旋转角度不因此改变
Trajectory.Straight.UseDisperseBurst=no      ; 布尔值，计算 `Trajectory.Straight.RotateCoord` 时是否按照扩散它的上级扩散抛体的 `Trajectory.Disperse.WeaponBurst` 的值而非武器的 `Burst`
Trajectory.Straight.AxisOfRotation=0,0,1     ; FLH坐标，请写完整，计算 `Trajectory.Straight.RotateCoord` 时的旋转轴，旋转轴会随单位朝向或目标位置到发射位置的向量旋转，长度不重要，只看方向（相反的向量也会反转旋转方向）
Trajectory.Straight.ProximityImpact=0        ; 整数型，撞击伤害次数，即抛体在检测到周围有单位时在单位所在的位置【额外】引爆一个弹头，为0代表不启用该逻辑，负数视为无限，最后一次触发是在其位置【额外】引爆一个弹头的同时引爆【本身】（撞击伤害也会对抛体本身的目标造成伤害）
Trajectory.Straight.ProximityWarhead=        ; Warhead类型，撞击伤害使用的弹头，可以让武器的 `Warhead` 仅使用一个索敌用的低补正假弹头来播放动画或是防止对抛体本身的目标造成二次伤害（即撞击弹头和武器弹头）
Trajectory.Straight.ProximityDamage=0        ; 整数型，撞击伤害的伤害量
Trajectory.Straight.ProximityRadius=0.7      ; 浮点型，撞击伤害触发的范围，不支持负数（不建议设置太大）
Trajectory.Straight.ProximityDirect=no       ; 布尔值，撞击伤害是否不引爆弹头而直接对目标造成伤害（不影响本体弹头引爆）
Trajectory.Straight.ProximityMedial=no       ; 布尔值，撞击伤害是否不在目标位置引爆，而是直接在抛体位置引爆，若 `Trajectory.Straight.ProximityDirect` 为是，则该项只会影响 `Trajectory.Straight.EdgeAttenuation` 对伤害的计算
Trajectory.Straight.ProximityAllies=no       ; 布尔值，撞击伤害是否对盟友生效
Trajectory.Straight.ProximityFlight=no       ; 布尔值，撞击伤害对空中单位是否生效
Trajectory.Straight.ThroughVehicles=yes      ; 布尔值，抛体是否不会被单位（车辆或飞机）阻挡，如果为否即在检测到单位（车辆或飞机）时会在其位置【额外】引爆一个弹头并同时引爆【本身】，且此时 `Trajectory.Straight.ProximityImpact` 不会对除障碍物以外任何单位（车辆或飞机）生效
Trajectory.Straight.ThroughBuilding=yes      ; 布尔值，抛体是否不会被建筑阻挡，如果为否即在检测到建筑时会在其位置【额外】引爆一个弹头并同时引爆【本身】，且此时 `Trajectory.Straight.ProximityImpact` 不会对除障碍物以外任何建筑生效
Trajectory.Straight.SubjectToGround=no       ; 布尔值，抛体低于地面高度时是否立刻引爆
Trajectory.Straight.ConfineAtHeight=0        ; 整数型，抛体会尽可能在离当前地面高度多高处飞行，小等于0代表不启用该逻辑，当速度大于256时失效（若 `SubjectToCliffs` 为yes，则其在悬崖高处都不会往下移动）
Trajectory.Straight.EdgeAttenuation=1.0      ; 浮点型，射程边缘修正比，抛体飞行到最大射程造成的伤害与距离一格内造成伤害的【比例】，一格外到射程内的变化是线性的，不支持负数（包括自身伤害、`Trajectory.Straight.PassDetonateDamage` 和 `Trajectory.Straight.ProximityDamage`）
Trajectory.Straight.CountAttenuation=1.0     ; 浮点型，伤害次数衰减率，即每次造成伤害后下一次造成伤害会是本次伤害的多少倍，不支持负数（包括自身伤害、`Trajectory.Straight.PassDetonateDamage` 和 `Trajectory.Straight.ProximityDamage`）
Inaccurate=no                                ; 布尔值，（原有功能-修复）启用随机散布（在启用散布后，如果还想保证命中，最好搭配一个较大的爆炸范围或大一些的Trajectory.Straight.TargetSnapDistance）
BallisticScatter.Min=0                       ; 浮点型，（原有功能-修复）最小散布距离，随距离增大而增大，代表每10格攻击距离最小散布偏移中心的单元格数
BallisticScatter.Max=                        ; 浮点型，（原有功能-修复）最大散布距离，随距离增大而增大，代表每10格攻击距离最大散布偏移中心的单元格数，默认值为 `CombatDamage` 中 `BallisticScatter` 的值
```

```{warning}
- 除非必要，否则请给 `Trajectory.Straight.ProximityRadius` 设置一个比较小的值，过大的值会显著增加性能消耗
- 注意 `Trajectory.Straight.PassDetonateWarhead` 和 `Trajectory.Straight.ProximityWarhead` 中使用的弹头必须注册
```

### 新增扩散抛体（ *pr #1295* ）

在 `rulesmd.ini` 之中：

```ini
[SOMEPROJECTILE]                             ; 弹道抛体（不和原版四类抛体共存）
Trajectory=                                  ; Trajectory类型，以下为【Disperse】
Trajectory.Speed=100.0                       ; 浮点型，弹道抛体的速度，此值定义的是在 [Trajectory.Disperse.UniqueCurve=no] 的情况下时抛体的最终速度（最高速度限制在256）
Trajectory.Disperse.UniqueCurve=no           ; 布尔值，是否启用模拟钱学森弹道，启用后以下19项及 `Trajectory.Speed` 无效，最高速度固定为192（应该不会有人范围很小的情况下还拿这个做弹道吧）
Trajectory.Disperse.PreAimCoord=0,0,0        ; FLH坐标，请写完整，发射设定，决定抛体初始飞行方向和距离，达到该坐标后会进行初次转向，为0,0,0时会直接朝着目标前进
Trajectory.Disperse.RotateCoord=0            ; 浮点型，发射设定，是否按照武器的 `Burst` 在以 `Trajectory.Disperse.PreAimCoord` 为角平分线的角度内旋转抛体发射方向，为0代表不启用该逻辑（负值会反转旋转方向）
Trajectory.Disperse.MirrorCoord=yes          ; 布尔值，发射设定，抛体在瞄准目标相对坐标进行攻击前，如果发射者开火时当前武器的 `Burst` 数为偶数，则 `Trajectory.Disperse.PreAimCoord` 中的L会镜像翻转，同时 `Trajectory.Disperse.RotateCoord` 计算的旋转方向也会反转，每一侧的每个相邻抛体之间的旋转角度不因此改变
Trajectory.Disperse.FacingCoord=no           ; 布尔值，发射设定，`Trajectory.Disperse.PreAimCoord` 的朝向是否跟随单位朝向
Trajectory.Disperse.ReduceCoord=yes          ; 布尔值，发射设定，`Trajectory.Disperse.PreAimCoord` 所指定的坐标长度是否代表每10格攻击距离的长度，其实际长度与攻击距离会成正比，当攻击距离很小的时候，指定的方向也会向目标进行缩减，可以简单理解为保证近距离命中的优化项
Trajectory.Disperse.UseDisperseBurst=no      ; 布尔值，发射设定，计算 `Trajectory.Disperse.RotateCoord` 时是否按照扩散它的上级扩散抛体的 `Trajectory.Disperse.WeaponBurst` 的值而非武器的 `Burst`
Trajectory.Disperse.AxisOfRotation=0,0,1     ; FLH坐标，请写完整，发射设定，计算 `Trajectory.Disperse.RotateCoord` 时的旋转轴，旋转轴会随单位朝向或目标位置到发射位置的向量旋转，长度不重要，只看方向（相反的向量也会反转旋转方向）
Trajectory.Disperse.LaunchSpeed=0            ; 浮点型，发射设定，抛体【初始】飞行速度，高于 `Trajectory.Speed` 会被直接降到该值
Trajectory.Disperse.Acceleration=10.0        ; 浮点型，通用设定，抛体飞行速度的加速度，按照此值每帧增加速度，巡航速度会逐渐达到 `Trajectory.Speed`
Trajectory.Disperse.ROT=30.0                 ; 浮点型，通用设定，抛体转向速度，可决定抛体的转向半径，转向半径会随速度增大而减小，即转向速度会随速度增大而增大
Trajectory.Disperse.LockDirection=no         ; 布尔值，通用设定，抛体在完成初次转向后是否锁定运动方向不再调整
Trajectory.Disperse.CruiseEnable=no          ; 布尔值，巡航设定，抛体在达到 `Trajectory.Disperse.PreAimCoord` 后的初次转向是否需要保持高度并朝目标前进
Trajectory.Disperse.CruiseUnableRange=5      ; 浮点型，巡航设定，距离目标多远时结束巡航阶段，不再保持巡航高度，并开始朝向目标前进，如果在达到 `Trajectory.Disperse.PreAimCoord` 时已经小于该值，会跳过巡航阶段（如果此值过小，则可能导致抛体永久处在巡航状态）
Trajectory.Disperse.CruiseAltitude=800       ; 整数型，巡航设定，抛体的巡航高度
Trajectory.Disperse.CruiseAlongLevel=no      ; 布尔值，巡航设定，抛体的巡航高度是否根据地形进行计算
Trajectory.Disperse.LeadTimeCalculate=yes    ; 布尔值，抛体在运动时是否计算目标的提前量（几乎不会增加性能消耗）
Trajectory.Disperse.RecordSourceCoord=no     ; 布尔值，抛体是否需要记录发射位置，发射位置将用于 `Trajectory.Disperse.Weapons` 中合适的武器，可以嵌套继承（需要双方均有设置）
Trajectory.Disperse.RetargetAllies=no        ; 布尔值，抛体本体在失去目标寻找新目标时是否选择盟友为目标
Trajectory.Disperse.RetargetRadius=0         ; 浮点型，抛体本体在失去目标后重新搜索新目标的半径，若未到达过 `Trajectory.Disperse.PreAimCoord` ，则以原目标最后的坐标为圆心，否则以自身前方这个距离的坐标为圆心，为0代表不启用重新搜索，会攻击原本的位置，为负数则会直接原地自爆，当原目标在空中时，新目标也只会在空中寻找，当原目标在地上时，新目标也只会在地上寻找
Trajectory.Disperse.TargetSnapDistance=0.5   ; 浮点型，抛体本体引爆时，当前目标在多近的距离内弹头会吸附过去
Trajectory.Disperse.SuicideAboveRange=0      ; 浮点型，抛体本体在飞行距离达到该值后直接自爆，为0代表不因此自爆
Trajectory.Disperse.SuicideShortOfROT=yes    ; 布尔值，抛体本体是否在发现转向能力不足时自爆
Trajectory.Disperse.SuicideIfNoWeapon=yes    ; 布尔值，抛体本体是否在扩散武器次数耗尽后自爆，原本没有次数时无效
Trajectory.Disperse.Weapons=                 ; Weapon列表，抛体的扩散武器
Trajectory.Disperse.WeaponBurst=             ; 整数型列表，抛体每次各扩散几个对应的武器，如果数量少于 `Trajectory.Disperse.Weapons` ，将使用该列表的最后一项
Trajectory.Disperse.WeaponCount=0            ; 整数型，抛体能扩散几次武器，负数为无限次，如果该值不为0，但扩散前发射者阵营已被击败，则抛体本身会直接自爆
Trajectory.Disperse.WeaponDelay=1            ; 整数型，抛体每隔多少帧扩散一次武器
Trajectory.Disperse.WeaponInitialDelay=0     ; 整数型，抛体在发射后多少帧第一次扩散武器，即扩散武器的初始延迟
Trajectory.Disperse.WeaponEffectiveRange=0   ; 浮点型，抛体扩散武器计时器会在距离目标这么近的距离时才会开始计时，为0代表不启用该逻辑，为负数代表只有在即将引爆本体的瞬间扩散最多一次武器
Trajectory.Disperse.WeaponSeparate=no        ; 布尔值，抛体每次扩散武器时，是否不再一次性发射列表中的所有武器，改为按列表顺序发射列表中的一组武器，遵循其 `Trajectory.Disperse.WeaponBurst`
Trajectory.Disperse.WeaponRetarget=no        ; 布尔值，抛体每次扩散武器时，扩散的武器是否自行寻找新目标，寻找目标的范围使用武器的 `Range`, 会读取 `Trajectory.Disperse.Weapons` 的 `CanTarget` 并判断攻击目标所需要的 `AttachedEffects` 是否满足
Trajectory.Disperse.WeaponLocation=no        ; 布尔值，抛体每次扩散武器时，扩散的武器在自行寻找新目标时，是否以扩散位置为中心的位置寻找，否则以原目标为中心位置寻找（不会直接攻击原目标）
Trajectory.Disperse.WeaponTendency=no        ; 布尔值，抛体每次扩散武器时，扩散的武器中每组的第一个武器是否必定会选择原目标
Trajectory.Disperse.WeaponHolistic=no        ; 布尔值，抛体每次扩散武器时，扩散的武器是否选择和原目标不同状态（在空中和在地上两种状态）的目标
Trajectory.Disperse.WeaponMarginal=no        ; 布尔值，抛体每次扩散武器时，扩散的武器是否会选择数木、路灯等物体作为次要目标
Trajectory.Disperse.WeaponToAllies=no        ; 布尔值，抛体每次扩散武器时，扩散的武器自行寻找新目标时是否选择盟友为目标
Trajectory.Disperse.WeaponDoRepeat=no        ; 布尔值，抛体每次扩散武器时，扩散的武器是否会因为搜索到的目标数量不足而尝试攻击相同目标；如果为是，当武器可以攻击单位和地面时，优先攻击单位，然后开始尝试重复攻击单位，只有当本轮没有任何可被攻击的单位存在于范围内时才会尝试攻击地面；如果为否，当武器可以攻击单位和地面时，优先攻击单位，然后尝试攻击所有可被攻击的地面格子，若本轮所有可选目标都已被锁定而仍能发射，则会停止发射剩余武器
```

```{warning}
- 除非必要，否则请给 `Trajectory.Disperse.RetargetRadius` 设置一个比较小的值，过大的值会显著增加性能消耗
- 注意 `Trajectory.Disperse.Weapons` 中使用的武器必须注册
- 如果你设置了 `Trajectory.Disperse.WeaponRetarget=yes` ，那么同样的，请给 `Trajectory.Disperse.Weapons` 中所列出的所有武器的 `Range` 设置一个比较小的值，过大的值会显著增加性能消耗
```

```{note}
- `Trajectory.Disperse.Weapons` 不支持使用 `Arcing=true` 的抛体的武器，支持 `Bolt.Disable1` 、`Bolt.Disable2` 、`Bolt.Disable3` 、`Bolt.Arcs` 的绘制效果，同时支持 Ares 的 `LaserThickness` 、`Beam.Color` 、`Beam.Duration` 、`Beam.Amplitude` 、`Beam.IsHouseColor` ，暂不支持 Ares 的 `Bolt.Color1` 、`Bolt.Color2` 、`Bolt.Color3`
- `Trajectory.Disperse.Weapons` 不会读取 `CanTargetHouses` 的设置，请使用 `Trajectory.Disperse.WeaponToAllies`
- 尽管 `Trajectory.Disperse.WeaponDoRepeat=no` 会禁用重复选择目标，但若武器能够攻击地面，则仍然可能因为锁定到目标所处的格子而攻击到重复目标，`Trajectory.Disperse.Weapons` 的索敌也是如此，若武器能够攻击地面，则仍然可能因为锁定到格子而攻击到本不能被索敌选择的目标
```

### 弹头伤害的额外补正（ *pr #1307* ）

在 `rulesmd.ini` 之中：

```ini
[CombatDamage]                               ; 全局伤害设置
DamageOwnerMultiplier=1.0                    ; 浮点型，对己方伤害的额外补正
DamageAlliesMultiplier=1.0                   ; 浮点型，对友方伤害的额外补正
DamageEnemiesMultiplier=1.0                  ; 浮点型，对敌方伤害的额外补正

[SOMEWARHEAD]                                ; 任意弹头
DamageOwnerMultiplier=                       ; 浮点型，对己方伤害的额外补正，默认值为 `CombatDamage` 中 `DamageOwnerMultiplier` 的值
DamageAlliesMultiplier=                      ; 浮点型，对友方伤害的额外补正，默认值为 `CombatDamage` 中 `DamageAlliesMultiplier` 的值
DamageEnemiesMultiplier=                     ; 浮点型，对敌方伤害的额外补正，默认值为 `CombatDamage` 中 `DamageEnemiesMultiplier` 的值
```

### 额外进度条（ *pr #1309* ）

在 `rulesmd.ini` 之中：

```ini
[AudioVisual]                                ; 视听通用设置
FactoryProgressDisplay=no                    ; 布尔值，开启后会在生产单位的主要工厂的血条下方显示当前产品的生产进度，注意当所属方为玩家时只有设定为主要的工厂才会显示，建筑中心的格子没有迷雾或被鼠标选中才会显示
FactoryProgressDisplay.Offset=0,0            ; 二维整数型，工厂生产进度显示的偏移坐标，分别为向右、向下
FactoryProgressDisplay.Pips=3                ; 整数型，工厂生产进度显示绘制的格子是使用SHP文件中的第几帧，注意和shpb不同，这里从第0帧开始
MainSWProgressDisplay=no                     ; 布尔值，开启后会在挂载超武的支援建筑的血条下方显示主要超武的冷却进度，只能是 `SuperWeapon` 中定义的超武且条件满足才会显示，建筑中心的格子没有迷雾或被鼠标选中才会显示
MainSWProgressDisplay.Offset=0,0             ; 二维整数型，建筑超武冷却显示的偏移坐标，分别为向右、向下
MainSWProgressDisplay.Pips=5                 ; 整数型，建筑超武冷却显示绘制的格子是使用SHP文件中的第几帧，注意和shpb不同，这里从第0帧开始
InvulnerableDisplay=no                       ; 布尔值，开启后会在无敌状态的任意单位的血条位置覆盖一层无敌的剩余时间，单位所处或建筑中心的格子没有迷雾或被鼠标选中才会显示
InvulnerableDisplay.Others.Offset=0,0        ; 二维整数型，单位无敌状态显示的偏移坐标，分别为向右、向下
InvulnerableDisplay.Buildings.Offset=0,0     ; 二维整数型，建筑无敌状态显示的偏移坐标，分别为向右、向下
InvulnerableDisplay.Others.Pips=17,18        ; 二维整数型，单位无敌状态显示绘制的格子是使用SHP文件中的第几帧，注意和shpb不同，这里从第0帧开始，分别是力场护盾、铁幕
InvulnerableDisplay.Buildings.Pips=5,4       ; 二维整数型，建筑无敌状态显示绘制的格子是使用SHP文件中的第几帧，注意和shpb不同，这里从第0帧开始，分别是力场护盾、铁幕
TemporalLifeDisplay=no                       ; 布尔值，开启后会在受到超时空武器攻击的任意单位的血条位置覆盖一层状态的剩余时间，单位所处或建筑中心的格子没有迷雾或被鼠标选中才会显示
TemporalLifeDisplay.Others.Offset=0,0        ; 二维整数型，单位超时空状态显示的偏移坐标，分别为向右、向下
TemporalLifeDisplay.Buildings.Offset=0,0     ; 二维整数型，建筑超时空状态显示的偏移坐标，分别为向右、向下
TemporalLifeDisplay.Others.Pips=17           ; 整数型，单位超时空状态显示绘制的格子是使用SHP文件中的第几帧，注意和shpb不同，这里从第0帧开始
TemporalLifeDisplay.Buildings.Pips=5         ; 整数型，建筑超时空状态显示绘制的格子是使用SHP文件中的第几帧，注意和shpb不同，这里从第0帧开始
ProgressDisplay.Others.PipsShape=PIPS.shp    ; SHP文件名，需要后缀，额外进度条中所有单位类绘制格子时使用的文件，注意色盘和背景各与原版相同
ProgressDisplay.Buildings.PipsShape=PIPS.shp ; SHP文件名，需要后缀，额外进度条中所有建筑类绘制格子时使用的文件，注意色盘和空格各与原版相同
```

### 悬浮空军单位抬升动作增强（ *pr #1318* ）

在 `rulesmd.ini` 之中：

```ini
[General]                                    ; 全局通用设置
JumpjetClimbPredictHeight=no                 ; 布尔值，开启后悬浮空军单位在移动时如果前方存在上升悬崖、建筑或单位时会提早升高高度
JumpjetClimbWithoutCutOut=no                 ; 布尔值，开启后悬浮空军单位如果面前存在上升悬崖、建筑或单位不会在升高时停止水平移动
```

### 防止单位出厂失败（ *pr #1347* ）

- 仅优化，无ini
- 简单来说，某个建筑在建造过程中不再会由于各种原因导致单位从它这里出厂，且各种被卡死在重工中的单位会在重工空闲时尝试再次出厂

### 新增抛射抛体（ *pr #1374* ）

- 选项 `Trajectory.Parabola.OpenFireMode` 可选类型：

| 类型             | 模式                       | 简述                             | 计算                                                                                     |
|:-----------------|:---------------------------|:---------------------------------|:-----------------------------------------------------------------------------------------|
| *Speed*          | 固定水平速度的自动计算模式 | 抛体的飞行时间是永久固定的       | 使用 `Trajectory.Speed` 和目标的坐标作为计算条件                                         |
| *Height*         | 固定最高高度的自动计算模式 | 抛体的引爆时间是相对固定的       | 使用 `Trajectory.Parabola.ThrowHeight` 和目标的坐标作为计算条件                          |
| *Angle*          | 固定发射角度的自动计算模式 | 抛体的发射角度是永久固定的       | 使用 `Trajectory.Parabola.LaunchAngle` 和目标的坐标作为计算条件                          |
| *SpeedAndHeight* | 固定水平速度和最高高度模式 | 轨迹将会随目标的高度发生高度变化 | 使用 `Trajectory.Speed` 和 `Trajectory.Parabola.ThrowHeight` 作为计算条件                |
| *HeightAndAngle* | 固定最高高度和发射角度模式 | 轨迹将会随目标的高度发生水平变化 | 使用 `Trajectory.Parabola.ThrowHeight` 和 `Trajectory.Parabola.LaunchAngle` 作为计算条件 |
| *SpeedAndAngle*  | 固定水平速度和发射角度模式 | 轨迹将会是永久固定的             | 使用 `Trajectory.Speed` 和 `Trajectory.Parabola.LaunchAngle` 作为计算条件                |

在 `rulesmd.ini` 之中：

```ini
[SOMEPROJECTILE]                             ; 弹道抛体(不和原版四类抛体共存)
Trajectory=                                  ; Trajectory类型，以下为【Parabola】
Trajectory.Speed=100.0                       ; 弹道抛体的速度，此值定义的是抛体水平方向速度，且仅用于模式0、模式3和模式5（最高速度无限制）
Trajectory.Parabola.DetonationDistance=0.4   ; 浮点型，若为正数，代表抛体在距离目标多远距离内就会引爆，若为负数，代表若抛体目标可以移动则会将目标直接丢失转为攻击其所在位置的地面格子，若为零则关闭功能
Trajectory.Parabola.TargetSnapDistance=0.5   ; 浮点型，抛体引爆时，当前目标在多近的距离内弹头会吸附过去
Trajectory.Parabola.OpenFireMode=Speed       ; 字符串，抛体的发射模式
Trajectory.Parabola.ThrowHeight=600          ; 整数型，抛体的抛射高度，抛体的水平速度将因距离发生改变，具体的高度将由发射位置的高度和目标位置的高度取较大值并增加该值，不支持非正数
Trajectory.Parabola.LaunchAngle=30           ; 浮点型，抛体的发射角度，抛体的水平速度和最高高度将因距离发生改变，使用模式2或模式5时支持(-90.0,90.0)，使用模式4时支持(0.0,90.0)
Trajectory.Parabola.LeadTimeCalculate=no     ; 布尔值，抛体在瞄准时是否计算目标的提前量，计算目标的提前量会在开火时延迟1帧发射，同时若抛体的速度过低，则会无法生效
Trajectory.Parabola.DetonationAngle=-90.0    ; 浮点型，抛体在当前速度方向与水平面之间的夹角小于该值时会提前引爆，当该值处在(-90.0,90.0)时生效，该值为零时（即需要抛体在最高点时引爆）会简化判断节约性能
Trajectory.Parabola.DetonationHeight=-1      ; 整数型，抛体在处于下降状态且低于发射位置高度加上该值时会提前引爆，非负数时生效
Trajectory.Parabola.BounceTimes=0            ; 整数型，抛体的弹跳次数
Trajectory.Parabola.BounceOnWater=no         ; 布尔值，抛体是否可以在水面上发生弹跳
Trajectory.Parabola.BounceDetonate=no        ; 布尔值，抛体是否可以在每次弹跳时额外引爆一次弹头
Trajectory.Parabola.BounceAttenuation=0.8    ; 浮点型，抛体弹跳伤害的衰减系数，即每次弹跳后下一次弹跳造成伤害会是本次伤害的多少倍
Trajectory.Parabola.BounceCoefficient=0.8    ; 浮点型，抛体弹跳的弹性系数，即每次弹跳后的速度是弹跳前速度的多少倍
Trajectory.Parabola.OffsetCoord=0,0,0        ; FLH坐标，请写完整，抛体会瞄准目标的这个相对坐标进行攻击，支持在此基础上启用随机散布
Trajectory.Parabola.RotateCoord=0            ; 浮点型，是否按照武器的 `Burst` 在以 `Trajectory.Parabola.OffsetCoord` 为角平分线的角度内旋转抛体发射方向，为0代表不启用该逻辑（负值会反转旋转方向）
Trajectory.Parabola.MirrorCoord=yes          ; 布尔值，抛体在瞄准目标相对坐标进行攻击前，如果发射者开火时当前武器的 `Burst` 数为偶数，则 `Trajectory.Parabola.OffsetCoord` 中的L会镜像翻转，同时 `Trajectory.Parabola.RotateCoord` 计算的旋转方向也会反转，每一侧的每个相邻抛体之间的旋转角度不因此改变
Trajectory.Parabola.UseDisperseBurst=no      ; 布尔值，计算 `Trajectory.Parabola.RotateCoord` 时是否按照扩散它的上级扩散抛体的 `Trajectory.Disperse.WeaponBurst` 的值而非武器的 `Burst`
Trajectory.Parabola.AxisOfRotation=0,0,1     ; FLH坐标，请写完整，计算 `Trajectory.Parabola.RotateCoord` 时的旋转轴，旋转轴会随单位朝向或目标位置到发射位置的向量旋转，长度不重要，只看方向（相反的向量也会反转旋转方向）
Inaccurate=no                                ; 布尔值，（原有功能-引入）启用随机散布（在启用散布后，如果还想保证命中，最好搭配一个较大的爆炸范围或大一些的Trajectory.Parabola.TargetSnapDistance）
BallisticScatter.Min=0                       ; 浮点型，（原有功能-引入）最小散布距离，随距离增大而增大，代表每10格攻击距离最小散布偏移中心的单元格数
BallisticScatter.Max=                        ; 浮点型，（原有功能-引入）最大散布距离，随距离增大而增大，代表每10格攻击距离最大散布偏移中心的单元格数，默认值为 `CombatDamage` 中 `BallisticScatter` 的值
Gravity=6.0                                  ; 浮点型，（原有功能-引入）抛体所受重力大小
```

```{warning}
- 在 `Trajectory.Parabola.OpenFireMode=Angle` 模式下，性能消耗较高，且由于可能攻击目标过高而无解，不建议使用此模式时启用 `SubjectToCliffs` 或启用 `AA` 并使用较小的 `MinimumRange`
```

```{note}
- `Trajectory.Parabola.BounceTimes` 默认只能在地面、斜坡和大部分悬崖处反弹，抛体速度过快时使用弹跳会产生问题，弹跳功能和 `Trajectory.Parabola.DetonationDistance` 并不冲突会同时生效，如需要抛体只会在弹跳次数耗尽后再爆炸，请将 `Trajectory.Parabola.DetonationDistance` 设置为非正数
```

### 观战者计分板显示电脑（ *pr #1386* ）

- 仅优化，无ini
- 现在电脑玩家也能出现在观战计分板上了

### 目标平均分配模式（ *pr #1453* ）

- 仅优化，无ini
- 拥有快捷键功能，位于 [控制] 面板

```{note}
- 范围为0时为游戏原本默认行为，通过快捷键可调整范围到4格、8格或16格，将会给选择的单位平均分配范围内的目标，只有当前单位将要执行的行为与鼠标显示的行为相同时才会分配，否则将会回到游戏原本默认行为（不会对空中单位生效），会通过一个指示圈来提示范围
- 开关快捷键是按住时生效
- 模式为 `None` 时为游戏原本默认行为，此时若范围不为0，则会显示一个绿圈，通过快捷键可调整模式到：
  - `Auto` ——如果当前单位将要执行的行为与鼠标显示的行为不同，且将要执行的行为会让单位移动到目标附近时，将该行为更换为原地警戒，此时会显示一个蓝圈
  - `Type` ——在 `Auto` 的基础上，在范围分配的目标中只会选择相同类型的目标（步兵、车辆、建筑），此时会显示一个黄圈
  - `Name` ——在 `Type` 的基础上，在范围分配的目标中只会选择同类目标（同名，或拥有相同的 `GroupAs` 名称），此时会显示一个红圈
- 关于2个模式快捷键：
  - 模式快捷键默认名为 `Distribution spread` 与 `Distribution filter`，可以在csf中添加名为 `TXT_DISTR_SPREAD` 与 `TXT_DISTR_FILTER` 和 `TXT_DISTR_SPREAD_DESC` 与 `TXT_DISTR_FILTER_DESC` 的项目来分别重写其在快捷键页面中的选项名称和详细说明
- 关于1个开关快捷键：
  - 开关快捷键默认名为 `Distribution hold down` ，可以在csf中添加名为 `TXT_DISTR_HOLDDOWN` 和 `TXT_DISTR_HOLDDOWN_DESC` 的项目来分别重写其在快捷键页面中的选项名称和详细说明
```

### 分裂空爆武器支持视觉效果绘制（ *pr #1466* ）

- 仅优化，无ini
- 分裂和空爆武器现在支持绘制激光、电弧、辐射和粒子

```{note}
- 支持 `Bolt.Disable1` 、`Bolt.Disable2` 、`Bolt.Disable3` 、`Bolt.Arcs`
- 同时支持 Ares 的 `LaserThickness` 、`Beam.Color` 、`Beam.Duration` 、`Beam.Amplitude` 、`Beam.IsHouseColor`
- 暂不支持 Ares 的 `Bolt.Color1` 、`Bolt.Color2` 、`Bolt.Color3`
```

### 出售和收起建筑弹头（ *pr #1468* ）

在 `rulesmd.ini` 之中：

```ini
[SOMEWARHEAD]                                ; 任意弹头
BuildingSell=no                              ; 布尔值，被命中的拥有建造动画的建筑是否会卖掉
BuildingUndeploy=no                          ; 布尔值，被命中的拥有 `UndeploysInto` 的建筑是否会收起成单位状态
BuildingUndeploy.Leave=no                    ; 布尔值，在 `BuildingUndeploy` 生效后是否会让目标前往周围威胁度低的空地
```

```{note}
- 这里的威胁度是使用单位价值进行计算的，如果周围某个单位并没有武器或为友军，则不会计入
```

### 盖特冷却计数拓展（ *pr #1469* ）

在 `rulesmd.ini` 之中：

```ini
[SOMETECHNO]                                 ; 任意 `IsGattling=yes` 的车辆或建筑
RateDown.Delay=0                             ; 整数型，单位停火后经过多少帧才开始使用 `RateDown` 降低盖特计数
RateDown.Ammo=-2                             ; 整数型，单位当前的弹药小于等于该值时使用 `RateDown.Cover` 替换原本的 `RateDown`
RateDown.Cover=0                             ; 整数型，单位当前的弹药小于等于 `RateDown.Ammo` 时使用该值替换原本的 `RateDown`
RateDown.Reset=no                            ; 布尔值，单位没有目标或更换目标时是否直接重置盖特计数
```

```{note}
- 单位默认的弹药量为-1
```

### AI基地建设逻辑修改（ *pr #1470* ）

在 `rulesmd.ini` 之中：

```ini
[AI]                                         ; AI逻辑设置
AIAutoDeployMCV=yes                          ; 布尔值，电脑在拥有一个建造场后是否仍会自动部署基地车
AISetBaseCenter=yes                          ; 布尔值，电脑在拥有一个建造场后是否仍会设置新部署的基地为新的基地中心节点
AIBiasSpawnCell=no                           ; 布尔值，电脑是否优先选择接近出生点位置的基地作为基地中心（战役无效）
AIForbidConYard=no                           ; 布尔值，电脑是否不能够放置拥有 `ConstructionYard=yes` 的建筑（仍会在基地被摧毁后尝试建造一次，可以通过减少基地的建造时间来减少这段无效时间）
```

### 受到控制停止武器冷却（ *pr #1471* ）

在 `rulesmd.ini` 之中：

```ini
[General]                                    ; 全局通用设置
NoRearm.UnderEMP=no                          ; 布尔值，所有单位处在EMP或失效状态下时，是否不更新武器冷却计时器
NoRearm.Temporal=no                          ; 布尔值，所有单位在被超时空武器锁定时，是否不更新武器冷却计时器
NoReload.UnderEMP=no                         ; 布尔值，所有单位处在EMP或失效状态下时，是否不更新弹药装填（不支持飞机弹药）计时器
NoReload.Temporal=no                         ; 布尔值，所有单位在被超时空武器锁定时，是否不更新弹药装填（不支持飞机弹药）计时器

[SOMETECHNO]                                 ; 任意步兵、车辆、飞机或建筑
NoRearm.UnderEMP=no                          ; 布尔值，所有单位处在EMP或失效状态下时，是否不更新武器冷却计时器，默认值为 `General` 中 `NoRearm.UnderEMP` 的值
NoRearm.Temporal=no                          ; 布尔值，所有单位在被超时空武器锁定时，是否不更新武器冷却计时器，默认值为 `General` 中 `NoRearm.Temporal` 的值
NoReload.UnderEMP=no                         ; 布尔值，所有单位处在EMP或失效状态下时，是否不更新弹药装填（不支持飞机弹药）计时器，默认值为 `General` 中 `NoReload.UnderEMP` 的值
NoReload.Temporal=no                         ; 布尔值，所有单位在被超时空武器锁定时，是否不更新弹药装填（不支持飞机弹药）计时器，默认值为 `General` 中 `NoReload.Temporal` 的值
```

### 侵略性移动攻击模式（ *pr #1473* ）

在 `rulesmd.ini` 之中：

```ini
[General]                                    ; 全局通用设置
AttackMove.Aggressive=no                     ; 布尔值，对单位使用 Ctrl+Shift 命令其进行移动攻击时是否会将无武器无威胁的敌军建筑视为自动攻击的目标

[SOMETECHNO]                                 ; 任意步兵、车辆、飞机
AttackMove.Aggressive=                       ; 布尔值，对单位使用 Ctrl+Shift 命令其进行移动攻击时是否会将无武器无威胁的敌军建筑视为自动攻击的目标，默认值为 `General` 中 `AttackMove.Aggressive` 的值
AttackMove.UpdateTarget=                     ; 布尔值，对单位使用 Ctrl+Shift 命令其进行移动攻击时是否会在拥有目标的情况下每隔索敌时间重新尝试索敌，若存在更高威胁的单位则会更换目标，若类型相同则不会更换，默认值为 `General` 中 `AttackMove.Aggressive` 的值
```

### 延迟自动攻击被心控单位（ *pr #1474* ）

在 `rulesmd.ini` 之中：

```ini
[General]                                    ; 全局通用设置
AttackMindControlledDelay=0                  ; 整数型，单位被心控超过这么多帧后，才会被其原本的友军所自动攻击或反击，不影响手动选择攻击，不受无源心控影响

[SOMEWARHEAD]                                ; 任意弹头
MindControl.ThreatDelay=                     ; 整数型，单位被这个心控弹头心控超过这么多帧后，才会被其原本的友军所自动攻击或反击，不影响手动选择攻击，不受无源心控影响，默认值为 `General` 中 `AttackMindControlledDelay` 的值
```

### 无排队快速进出载具（ *pr #1475* ）

在 `rulesmd.ini` 之中：

```ini
[General]                                    ; 全局通用设置
NoQueueUpToEnter=no                          ; 布尔值，进入载具的行为是否不需要排队
NoQueueUpToUnload=no                         ; 布尔值，离开载具的行为是否不需要等待

[SOMEUNIT]                                   ; 只能是车辆
NoQueueUpToEnter=no                          ; 布尔值，该车辆进入载具的行为是否不需要排队，默认值为 `General` 中 `NoQueueUpToEnter` 的值
NoQueueUpToUnload=no                         ; 布尔值，该车辆离开载具的行为是否不需要等待，默认值为 `General` 中 `NoQueueUpToUnload` 的值
```

### 建筑图标预览和叠加显示（ *pr #1477* ）

在 `ra2md.ini` 之中：

```ini
[Phobos]                                     ; Phobos设置
ShowBuildingStatistics=no                    ; 布尔值，是否给建筑类型图标的右上角增加一个数字显示，显示当前拥有的该类型建筑的数量
```

在 `rulesmd.ini` 之中：

```ini
[AudioVisual]                                ; 视听通用设置
Cameo.AlwaysExist=no                         ; 布尔值，所有可建造类型是否永远不会不显示图标，即在不满足任意建造条件时仍会显示灰色图标，且会改变播放EVA语音的时机（注意这受到所属方影响，且科技等级必须要合法）
Cameo.OverlayShapes=                         ; SHP文件名，需要后缀，在建造图标之上绘制图案时使用的文件
Cameo.OverlayFrames=                         ; 四维整数型，分别代表当前拥有该类型的实体时、可以自动建造该类型时、当前类型暂时不能造时和当前类型无前提条件时分别使用SHP文件中的第几帧，为负数时代表对应条件下不需要绘制
Cameo.OverlayPalette=                        ; PAL文件名，需要后缀，在建造图标之上绘制图案时使用的色盘

[SOMETECHNO]                                 ; 任意步兵、车辆、飞机或建筑
Cameo.AlwaysExist=                           ; 布尔值，该类型是否能够一直显示图标，即在不满足任意建造条件（仅建造条件，`Owner`、`RequiredHouses`、`ForbiddenHouses` 和 `TechLevel` 限制为必需项）时仍会显示灰色图标，且会改变播放EVA语音的时机，默认值为 `General` 中 `Cameo.AlwaysExist` 的值
Cameo.AuxTechnos=                            ; Techno列表，如果填写（不必须是建筑，会递归判断），则当拥有这些类型中任意一种，或能够满足这些类型中任意一种的 `Owner`、`RequiredHouses`、`ForbiddenHouses` 和 `TechLevel` 限制、 `Cameo.AuxTechno` 和 `Cameo.NegTechno` 时，才会显示 `Cameo.AlwaysExist` 为是的图标；如果不填写，则除了基本条件外，只需满足 `AIBasePlanningSide` 就会显示
Cameo.NegTechnos=                            ; Techno列表，如果填写（不必须是建筑），则当拥有这些类型中任意一种时，不再显示满足 `Cameo.AlwaysExist` 条件的灰图标（不影响建造数量限制等条件导致的灰图标）
UIDescription.Unbuildable=                   ; CSF条目，因 `Cameo.AlwaysExist` 原因使得图标为灰色时显示的文本

[SOMEBUILDING]                               ; 只能是建筑
Cameo.ShouldCount=                           ; 布尔值，是否需要被 `ShowBuildingStatistics` 所统计，默认值为 `BuildLimit` 有设置或不是 `BuildCat=Combat`
```

在 `artmd.ini` 之中：

```ini
[SOMETECHNO]                                 ; 任意步兵、车辆、飞机或建筑
GreyCameoPCX=                                ; PCX文件，需要后缀，当前类型无前提条件时在建造图标上方额外绘制的图像，注意这同样会覆盖灰色半透明图层，有需要请直接处理该图像文件为灰色
```

### 建筑建造范围拓展和网格边界显示（ *pr #1478* ）

在 `ra2md.ini` 之中：

```ini
[Phobos]                                     ; Phobos设置
DrawAdjacentBoundary=no                      ; 布尔值，是否绘制建筑的建造判定边界
```

在 `rulesmd.ini` 之中：

```ini
[General]                                    ; 全局通用设置
CheckUnitBaseNormal=no                       ; 布尔值，是否需要检测单位扩展建筑范围

[AudioVisual]                                ; 视听通用设置
PlacementGrid.Expand=no                      ; 布尔值，是否需要彩色化显示建造网格
PlacementGrid.LandFrames=1,0,0               ; 三维整数型，分别代表在非水上建造时，该格子处在 存在单位、超出范围或完全正常 状态时，显示的建筑格子在place.shp中的帧号（从0开始，由于不改变原有的红格设计，建议从尾部增加）
PlacementGrid.WaterFrames=1,0,0              ; 三维整数型，分别代表在水面上建造时，该格子处在 存在单位、超出范围或完全正常 状态时，显示的建筑格子在place.shp中的帧号（从0开始，由于不改变原有的红格设计，建议从尾部增加）

[SOMEUNIT]                                   ; 只能是车辆
UnitBaseNormal=no                            ; 布尔值，该单位是否能扩展己方的建筑范围
UnitBaseForAllyBuilding=no                   ; 布尔值，该单位是否能扩展其它友方的建筑范围
```

```{note}
- 启用 `CheckUnitBaseNormal` 会增加少量性能消耗，启用 `PlacementGrid.Expand` 也会增加一定程度的性能消耗
```

### 建筑建造和部署行为拓展和自定义激光围墙（ *pr #1479* ）

在 `rulesmd.ini` 之中：

```ini
[General]                                    ; 全局通用设置
ExtendedBuildingPlacing=no                   ; 布尔值，是否允许建筑能在友方单位头顶建造，并尝试散开占据这些格子的友方单位
AutoBuilding=no                              ; 布尔值，所有建筑是否不需要手动点击图标放置，而是在完成建造后自动放置

[SOMEBUILDING]                               ; 只能是建筑
AutoBuilding=                                ; 布尔值，该建筑是否不需要手动点击图标放置，而是在完成建造后自动放置，默认值为 `General` 中 `AutoBuilding` 的值
AutoBuilding.Gap=1                           ; 整数型，建筑自动放置时需要隔最近的建筑多少格距离
LimboBuild=no                                ; 布尔值，该建筑从侧边栏被建造时，是否将成为虚拟建筑（会在完成建造后自动放置），如果需要给AI用，请不要给 [BuildPower] 里列出的建筑使用
LimboBuildID=-1                              ; 整数型，该建筑被建造成为虚拟建筑时的虚拟建筑ID
PlaceBuilding.OnLand=                        ; Building类型，定义当该建筑 `WaterBound=yes` 时放置到陆地上会切换成什么建筑
PlaceBuilding.OnWater=                       ; Building类型，定义当该建筑 `WaterBound=no` 时放置到水面上会切换成什么建筑
LaserFencePost.Fence=                        ; Building类型，只能是 `LaserFencePost=yes` 的建筑，若此处定义的建筑有 `LaserFence=yes` ，则会以此建筑替换默认使用的激光围墙类型（列表中第一个拥有 `LaserFence=yes` 的建筑类型），且使用不同激光围墙的激光围墙柱之间不会相互连接

[SOMETECHNO]                                 ; 任意步兵、车辆、飞机或建筑
CanBeBuiltOn=no                              ; 布尔值，该类型是否不影响建筑建造且会在建筑在其头顶建造时直接消失
```

- 拥有快捷键功能，位于 [控制] 面板
- 只有 `AutoBuilding=yes` 的建筑会受到快捷键影响而被禁止自动放置，而 `AutoBuilding=no` 的建筑不会因此而能够自动放置。默认开启状态

```{note}
- 启用 `ExtendedBuildingPlacing` 会在建筑拍下时增加少量性能消耗
- 启用 `AutoBuilding` 会在建筑完成时增加少量性能消耗，如果找不到地方放不下去，则会每隔一段时间再次进行尝试，且不支持激光围墙、闸门和地形
- 关于1个开关快捷键：
  - 开关快捷键默认名为 `Toggle Auto Building` ，可以在csf中添加名为 `TXT_AUTO_BUILD` 和 `TXT_AUTO_BUILD_DESC` 的项目来分别重写其在快捷键页面中的选项名称和详细说明
- 如果所有 `LaserFencePost=yes` 的建筑都使用 `LaserFencePost.Fence` 时能够降低性能消耗
- 使用 `PlaceBuilding.OnLand` 和 `PlaceBuilding.OnWater` 时，过大和过小的建筑进行切换可能产生小问题，此时将以大面积建筑优先进行判断，且不支持任意一方拥有 `PlaceAnywhere` 或使用 `LimboBuild` ，同时需要正确设置双方的 `Naval`
```

### 单位炮塔旋转行为拓展（ *pr #1480* ）

在 `rulesmd.ini` 之中：

```ini
[General]                                    ; 全局通用设置
ExpandTurretRotation=no                      ; 布尔值，是否开启以下的炮塔旋转相关功能

[AudioVisual]                                ; 视听通用设置
Turret.IdleRotate=no                         ; 布尔值，所有有炮塔的单位是否会在闲置时随机旋转炮塔
Turret.PointToMouse=no                       ; 布尔值，所有有炮塔的单位是否会在闲置或移动并且再被选中时旋转炮塔朝向鼠标位置（多人模式会自动禁用）
Turret.IdleRestartMin=150                    ; 整数型，单位在停止指令后至少多少帧会认为是处于闲置状态并开始旋转炮塔
Turret.IdleRestartMax=300                    ; 整数型，单位在停止指令后至多多少帧会认为是处于闲置状态并开始旋转炮塔
Turret.IdleIntervalMin=150                   ; 整数型，单位处在闲置状态下旋转炮塔后至少间隔多少帧会再次旋转炮塔
Turret.IdleIntervalMax=450                   ; 整数型，单位处在闲置状态下旋转炮塔后至多间隔多少帧会再次旋转炮塔

[SOMEUNIT]                                   ; 任意 `Turret=yes` 的车辆
Turret.IdleRotate=                           ; 布尔值，当前单位是否会在闲置时随机旋转炮塔，默认值为 `AudioVisual` 中 `Turret.IdleRotate` 的值
Turret.PointToMouse=                         ; 布尔值，当前单位是否会在（闲置或仅移动中）且被选中时旋转炮塔朝向鼠标位置，默认值为 `AudioVisual` 中 `Turret.PointToMouse` 的值
Turret.Restriction=180.0                     ; 浮点型，炮塔可以向两侧转动的角度，若该值低于180.0则会在角度不合适时自动转动身体而不需要设置 `Turret.BodyOrientation` ，如果确实有需要设置 `Turret.BodyOrientation` ，则不合适的值可能导致问题
Turret.ExtraAngle=0                          ; 浮点型，炮塔额外的转动角度，同时 `Turret.Restriction` 的限制范围也会随该值进行转动，正数为顺时针方向，负数为逆时针方向，即炮塔应该用何种角度回正或是对着目标，0.0~180.0为左侧面对，-180.0~0.0为右侧面对
Turret.BodyOrientation=no                    ; 布尔值，身体是否需要在开火的时候对准目标，启用后以下两项才生效
Turret.BodyOrientationAngle=0                ; 浮点型，身体对准目标时额外的转动角度，正数为顺时针方向，负数为逆时针方向，即身体应该用何种角度对着目标，0.0~180.0为左侧面对，-180.0~0.0为右侧面对
Turret.BodyOrientationSymmetric=yes          ; 布尔值，身体对准目标时额外的转动角度是否左右均可，不必判断具体往哪一边，即身体既可以用左侧也可以用右侧对着目标
```

### 新增锁定抛体（ *pr #1481* ）

- `Trajectory.Tracing.TraceMode` 可选类型：（用于计算 `Trajectory.Tracing.OffsetCoord` 的坐标轴，原点位于追踪目标上，H轴不随追踪目标的倾斜偏转影响，永远朝向地图正上方）

| 类型         | 模式           | 简述                                        |
|:-------------|:---------------|:--------------------------------------------|
| *Connection* | 连线向量模式   | 以发射位置与目标位置之间向量的水平分量为F轴 |
| *Global*     | 地图方向模式   | 以地图的右下方方向为F轴                     |
| *Body*       | 跟随身体模式   | 以追踪目标的身体朝向为F轴                   |
| *Turret*     | 跟随炮塔模式   | 以追踪目标的炮塔朝向为F轴                   |
| *RotateCW*   | 顺时针旋转模式 | 以FL方向偏移的合成量为半径，绕H轴顺时针旋转 |
| *RotateCCW*  | 逆时针旋转模式 | 以FL方向偏移的合成量为半径，绕H轴逆时针旋转 |

在 `rulesmd.ini` 之中：

```ini
[SOMEPROJECTILE]                             ; 弹道抛体(不和原版四类抛体共存)
Trajectory=                                  ; Trajectory类型，以下为【Tracing】
Trajectory.Speed=100.0                       ; 弹道抛体的速度，此值定义的是抛体追击单位当前目标的速度（最高速度无限制）
Trajectory.Tracing.TraceMode=Connection      ; 字符串，抛体的追踪模式
Trajectory.Tracing.TheDuration=0             ; 整数型，锁定的持续时间，持续时间结束时引爆，单位为帧，如果为非正数，则使用武器 `ROF` - 10 作为持续时间，持续时间最低为1
Trajectory.Tracing.TolerantTime=-1           ; 整数型，锁定闲置的容忍时间，抛体在失去目标超过这么长时间后会引爆，若为0，则会在切换目标时直接引爆
Trajectory.Tracing.ROT=-1                    ; 整数型，抛体的转动速度，为负数时跟随移动的方向，为0时会始终朝向目标，为正数时会根据该速度向目标转动，如果 `Trajectory.Tracing.BulletSpin` 为是则由正负决定方向，数值决定速度
Trajectory.Tracing.BulletSpin=no             ; 布尔值，抛体是否会一直旋转
Trajectory.Tracing.PeacefullyVanish=no       ; 布尔值，抛体在最后将要引爆时是否直接消失，即不产生动画和造成伤害
Trajectory.Tracing.TraceTheTarget=yes        ; 布尔值，抛体追踪的目标是否为抛体的目标，并且发射的追踪武器是由单位朝抛体发射，否则为追踪发射者，发射的追踪武器是由抛体朝目标发射，当发射者死亡时，抛体也会一同引爆
Trajectory.Tracing.CreateAtTarget=no         ; 布尔值，抛体是否在目标位置上直接生成
Trajectory.Tracing.CreateCoord=0,0,0         ; FLH坐标，请写完整，抛体会在原生成位置的基础上偏移这个坐标生成，不由 `Trajectory.Tracing.TraceMode` 决定具体位置
Trajectory.Tracing.OffsetCoord=0,0,0         ; FLH坐标，请写完整，抛体会追踪其追踪目标的这个位置，由 `Trajectory.Tracing.TraceMode` 决定具体位置
Trajectory.Tracing.WeaponCoord=0,0,0         ; FLH坐标，请写完整，当 `Trajectory.Tracing.TraceTheTarget` 为否时从抛体位置发射的武器的具体位置会叠加该位置，可以视作是抛体发射武器的FLH
Trajectory.Tracing.UseDisperseCoord=no       ; 布尔值，追踪武器的发射位置是否使用扩散它的上级扩散抛体的发射位置替换固定位置，需要上级抛体拥有 `Trajectory.Disperse.RecordSourceCoord` ，注意只有在原本的发射位置应该在单位上时才会生效
Trajectory.Tracing.Weapons=                  ; Weapon列表，抛体的追踪武器
Trajectory.Tracing.WeaponCount=              ; 整数型列表，抛体需要发射几次对应武器，为零会直接计算冷却而不发射，负数视为无限，如果数量少于 `Trajectory.Tracing.Weapons` ，将使用该列表的最后一项
Trajectory.Tracing.WeaponDelay=              ; 整数型列表，抛体在发射对应武器后需要等待多久才能进行下一次发射，至少为1，如果数量少于 `Trajectory.Tracing.Weapons` ，将使用该列表的最后一项
Trajectory.Tracing.WeaponInitialDelay=0      ; 整数型，抛体在首次发射前需要等待多久
Trajectory.Tracing.WeaponCycle=-1            ; 整数型，抛体能够发射几轮武器，为零不会发射武器，负数视为无限
Trajectory.Tracing.WeaponCheck=no            ; 布尔值，抛体在发射追踪武器前是否会检查自己的朝向，如果 `Trajectory.Tracing.Synchronize` 为否或 `Trajectory.Tracing.TraceTheTarget` 为是或 `Trajectory.Tracing.BulletSpin` 为是或 `Trajectory.Tracing.ROT` 为负数时无视该项强制不检查
Trajectory.Tracing.Synchronize=yes           ; 布尔值，抛体的目标是否同步发射者的目标，如果不同步，抛体不会更新目标，但当 `Trajectory.Tracing.TraceTheTarget=no` 时，发射的追踪武器会根据其射程自行选择目标攻击
Trajectory.Tracing.SuicideAboveRange=no      ; 布尔值，抛体的目标如果超过射程是否直接引爆
Trajectory.Tracing.SuicideIfNoWeapon=no      ; 布尔值，抛体在发射完最后的武器后是否直接引爆
```

```{warning}
- 注意 `Trajectory.Tracing.Weapons` 中使用的武器必须注册
- 尽管 `Trajectory.Tracing.Weapons` 中使用的武器支持嵌套使用，但请合理运用
- 如果你设置了 `Trajectory.Tracing.TraceTheTarget=no` 和 `Trajectory.Tracing.Synchronize=no` ，那么请给 `Trajectory.Tracing.Weapons` 中所列出的所有武器的 `Range` 设置一个比较小的值，过大的值会显著增加性能消耗
```

```{note}
- `Trajectory.Tracing.Weapons` 不支持使用 `Arcing=true` 的抛体的武器，支持 `Bolt.Disable1` 、`Bolt.Disable2` 、`Bolt.Disable3` 、`Bolt.Arcs` 的绘制效果，同时支持 Ares 的 `LaserThickness` 、`Beam.Color` 、`Beam.Duration` 、`Beam.Amplitude` 、`Beam.IsHouseColor` ，暂不支持 Ares 的 `Bolt.Color1` 、`Bolt.Color2` 、`Bolt.Color3`
```

### 开火瞬间附加或移除AE（ *pr #1482* ）

在 `rulesmd.ini` 之中：

```ini
[SOMEWEAPON]                                 ; 任意武器
AttachEffect.AttachTypes=
AttachEffect.CumulativeRefreshAll=false
AttachEffect.CumulativeRefreshAll.OnAttach=false
AttachEffect.CumulativeRefreshSameSourceOnly=true
AttachEffect.RemoveTypes=
AttachEffect.RemoveGroups=
AttachEffect.CumulativeRemoveMinCounts=
AttachEffect.CumulativeRemoveMaxCounts=
AttachEffect.DurationOverrides=
```

```{note}
- 懒得写了，和弹头的类似，公版说明书都有
- 在开火后抛体生成的瞬间附加或移除，即会先判断 `AttachEffect.RequiredTypes` 等等条件
```

### 手动回复弹药（ *pr #1493* ）

在 `rulesmd.ini` 之中：

```ini
[SOMETECHNO]                                 ; 任意步兵、车辆或建筑
CanManualReload=no                           ; 布尔值，该单位是否能够手动回复弹药
CanManualReload.ResetROF=yes                 ; 布尔值，该单位手动回复弹药时是否重置ROF
CanManualReload.DetonateWarhead=             ; Warhead类型，该单位手动回复弹药时在自己的位置引爆的一个伤害为1的弹头，不填则没有
CanManualReload.DetonateConsume=0            ; 整数型，只有当手动回复弹药前的弹药大于等于该值时才会引爆 `CanManualReload.DetonateWarhead`
```

- 拥有快捷键功能，位于 [控制] 面板
- 单位响应手动回复弹药时会将弹药清零，并进入空弹回复状态

```{note}
- 关于1个功能快捷键：
  - 功能快捷键默认名为 `Manual Reload Ammo` ，可以在csf中添加名为 `TXT_MANUAL_RELOAD` 和 `TXT_MANUAL_RELOAD_DESC` 的项目来分别重写其在快捷键页面中的选项名称和详细说明
```

### 合并范围伤害对建筑的结算（ *pr #1504* ）

在 `rulesmd.ini` 之中：

```ini
[CombatDamage]                               ; 全局伤害设置
MergeBuildingDamage=no                       ; 布尔值，所有弹头是否合并对建筑的范围伤害，只结算一次

[SOMEWARHEAD]                                ; 任意弹头
MergeBuildingDamage=                         ; 布尔值，该弹头是否合并对建筑的范围伤害，只结算一次，默认值为 `CombatDamage` 中 `MergeBuildingDamage` 的值
```

```{note}
- 功能与 `CellSpread.MaxAffect` 不同
- 由于取整问题，可能导致伤害在一定程度上提升
```

### 优化让路逻辑（ 暂无pr ）

在 `rulesmd.ini` 之中：

```ini
[General]                                    ; 全局通用设置
ExtendedScatterAction=no                     ; 布尔值，是否使用优化的让路逻辑
```

### 占据位空气墙修复（ 暂无pr ）

在 `rulesmd.ini` 之中：

```ini
[General]                                    ; 全局通用设置
CleanUpAirBarrier=0                          ; 整数型，大于0时启用，每隔多久刷新全图格子的占据位状态，如果当前格子占据位不为空但链表上没有单位，且周围不存在任何移动中的单位，则会刷新占据位状态
```

```{warning}
- 实验性功能，使用暴力解法，频率过高会影响性能，并可能导致车辆在移动时重叠
```

### 底边栏选择信息（ 暂无pr ）

在 `ra2md.ini` 之中：

```ini
[Phobos]                                     ; Phobos设置
SelectedDisplay.Enable=no                    ; 布尔值，底边栏在开始游戏时默认是否开启
FPSCounter.Enable=no                         ; 布尔值，适配的FPS显示在开始游戏时默认是否开启
```

在 `rulesmd.ini` 之中：

```ini
[AudioVisual]                                ; 视听通用设置
SelectedInfantryMissingPCX=                  ; PCX文件，需要后缀，仅用于底边栏，确认该步兵使用的是 `MissingCameo` 时，会替换显示的图标
SelectedVehicleMissingPCX=                   ; PCX文件，需要后缀，仅用于底边栏，确认该车辆使用的是 `MissingCameo` 时，会替换显示的图标
SelectedAircraftMissingPCX=                  ; PCX文件，需要后缀，仅用于底边栏，确认该飞机使用的是 `MissingCameo` 时，会替换显示的图标
SelectedBuildingMissingPCX=                  ; PCX文件，需要后缀，仅用于底边栏，确认该建筑使用的是 `MissingCameo` 时，会替换显示的图标

[SOMETECHNO]                                 ; 任意步兵、车辆、飞机或建筑
SelectedInfo.UpperType=Shield                ; InfoType类型（和 `DigitalDisplayType` 中的 `InfoType` 相同），单选单位时底边栏显示在上方的信息类型
SelectedInfo.UpperColor=153,153,255          ; RGB颜色，请写完整，单选单位时底边栏显示在上方的信息颜色，为 0,0,0 时会根据当前值和最大值的比例以及 `AudioVisual` 中 `ConditionYellow` 和 `ConditionRed` 的比例显示红黄绿的颜色
SelectedInfo.BelowType=Health                ; InfoType类型（和 `DigitalDisplayType` 中的 `InfoType` 相同），单选单位时底边栏显示在下方的信息类型
SelectedInfo.BelowColor=0,0,0                ; RGB颜色，请写完整，单选单位时底边栏显示在下方的信息颜色，为 0,0,0 时会根据当前值和最大值的比例以及 `AudioVisual` 中 `ConditionYellow` 和 `ConditionRed` 的比例显示红黄绿的颜色
```

- 拥有快捷键功能，位于 [控制] 面板
- 默认开启状态，可以点击图标，图标顺序按照注册表中的顺序从左到右排列，不同类型则从左到右为步兵、车辆、飞机、建筑，左键点击：选择其中随机一个该类型单位，shift+左键：选择其中所有该类型单位，右键点击：取消选中随机一个该类型单位，shift+右键：取消选中所有该类型单位，悬浮一段时间则会显示提示，会读取 `GroupAs` 判断是否为同一类型

```{note}
- 关于1个开关快捷键：
  - 开关快捷键默认名为 `Selected technos display` ，可以在csf中添加名为 `TXT_SELECTED_INFO` 和 `TXT_SELECTED_INFO_DESC` 的项目来分别重写其在快捷键页面中的选项名称和详细说明
  - 开关时显示的提示信息，可以在csf中添加名为 `TXT_SELECT_VISIBLE` 和 `TXT_SELECT_INVISIBLE` 的项目来分别定义开和关时显示的文本
- 关于适配的FPS显示的开关快捷键：
  - 开关快捷键默认名为 `Phobos FPS Counter` ，可以在csf中添加名为 `TXT_FPSC_INFO` 和 `TXT_FPSC_INFO_DESC` 的项目来分别重写其在快捷键页面中的选项名称和详细说明，当按下 `Alt` 键时，可以增加其背景的不透明度
- 关于右下角各种计时器的背景：
  - 当按下 `Alt` 键时，可以增加其背景的不透明度
```

### 屏幕中显示字幕信息（ 暂无pr ）

在 `ra2md.ini` 之中：

```ini
[Phobos]                                     ; Phobos设置
MessageDisplayInCenter=no                    ; 布尔值，是否直接在屏幕中显示字幕、聊天、提示信息，而非左上角，背景为半透明，鼠标悬浮在字幕区域时会增加其不透明度，并延长显示时间（字幕区域不判断宽度，只判断高度）
```

### 独特单位独立显示（ 暂无pr ）

在 `rulesmd.ini` 之中：

```ini
[SOMETECHNO]                                 ; 任意步兵、车辆、飞机或建筑
UniqueTechno=no                              ; 布尔值，该单位是否被视为独特单位，独特单位会在右上角显示一个独立图标，最多同时显示八个独特单位
```

- 拥有快捷键功能，位于 [控制] 面板
- 默认开启状态，可以点击图标单独选中单位（若处在载具中则会选中载具），若已单独选中，则会居中视野；会显示血条、护盾条和铁幕剩余时间（若单位处在生产状态，会改为显示生产进度条）；若单位正处在铁幕状态下，会持续显示一层半透明黑色，而若单位血量较低，会浮动显示一层较浅的红色；当单位受到攻击时会短暂显示一层半透明红色，当单位正在攻击时会短暂显示一层半透明黄色，当单位正被空袭指示时会持续显示一层半透明红色，当单位正被超时空武器锁定时会持续显示一层半透明蓝色，当单位正被飞碟汲取或被磁电控制时会持续显示一层半透明紫色，当单位处于EMP中时会持续显示一层半透明灰色，当单位处于载具中时会在血条外显示一圈代表载具血量的橙色，且护盾和铁幕时间会被载具所替换，当单位驻军在建筑中或坦克碉堡中时会在血条外显示一圈完整的紫色，护盾和铁幕时间不显示

```{note}
- 关于1个开关快捷键：
  - 开关快捷键默认名为 `Heros display` ，可以在csf中添加名为 `TXT_HEROS_INFO` 和 `TXT_HEROS_INFO_DESC` 的项目来分别重写其在快捷键页面中的选项名称和详细说明
  - 开关时显示的提示信息，可以在csf中添加名为 `TXT_HEROS_VISIBLE` 和 `TXT_HEROS_INVISIBLE` 的项目来分别定义开和关时显示的文本
```
